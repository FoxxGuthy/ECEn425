; Generated by c86 (BYU-NASM) 5.1 (beta) from lab8app.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
nextMsg:
	DW	0
bin0B:
	DB	0
bin1B:
	DB	0
bin0BL:
	DB	0
bin1BL:
	DB	0
bin0A:
	DB	0
bin1A:
	DB	0
bin0AL:
	DB	0
bin1AL:
	DB	0
L_lab8app_3:
	DB	"  addToQ: queue overflow! ",0xA,0
L_lab8app_2:
	DB	" DIR:",0
L_lab8app_1:
	DB	"ATQ: CMD:",0
	ALIGN	2
addToQueue:
	; >>>>> Line:	68
	; >>>>> void addToQueue(int pieceID, int cmd, int direction){ 
	jmp	L_lab8app_4
L_lab8app_5:
	; >>>>> Line:	70
	; >>>>> MsgArray[nextMsg].pieceID = pieceID; 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	mov	si, ax
	add	si, MsgArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	71
	; >>>>> MsgArray[nextMsg].cmd = cmd; 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	add	ax, MsgArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	72
	; >>>>> MsgArray[nextMsg].direction = direction; 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	add	ax, MsgArray
	mov	si, ax
	add	si, 4
	mov	ax, word [bp+8]
	mov	word [si], ax
	; >>>>> Line:	73
	; >>>>> if(0==1){ 
	jmp	L_lab8app_6
	; >>>>> Line:	74
	; >>>>> printString("ATQ: CMD:"); 
	mov	ax, L_lab8app_1
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	75
	; >>>>> printInt(cmd); 
	push	word [bp+6]
	call	printInt
	add	sp, 2
	; >>>>> Line:	76
	; >>>>> printString(" DIR:"); 
	mov	ax, L_lab8app_2
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	77
	; >>>>> printInt(direction); 
	push	word [bp+8]
	call	printInt
	add	sp, 2
	; >>>>> Line:	78
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab8app_6:
	; >>>>> Line:	81
	; >>>>> if (YKQPost(MsgQPtr, (void *) &(MsgArray[nextMsg]) 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	add	ax, MsgArray
	push	ax
	push	word [MsgQPtr]
	call	YKQPost
	add	sp, 4
	test	ax, ax
	jne	L_lab8app_7
	; >>>>> Line:	82
	; >>>>> printString("  addToQ: queue overflow! \n"); 
	mov	ax, L_lab8app_3
	push	ax
	call	printString
	add	sp, 2
	jmp	L_lab8app_8
L_lab8app_7:
	; >>>>> Line:	83
	; >>>>> else if (++nextMsg >= 80) 
	mov	ax, word [nextMsg]
	inc	ax
	mov	word [nextMsg], ax
	cmp	ax, 80
	jl	L_lab8app_9
	; >>>>> Line:	84
	; >>>>> nextMsg = 0; 
	mov	word [nextMsg], 0
L_lab8app_9:
L_lab8app_8:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_4:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_5
	ALIGN	2
setOrientation:
	; >>>>> Line:	88
	; >>>>> void setOrientation(int Orientation){ 
	jmp	L_lab8app_11
L_lab8app_12:
	; >>>>> Line:	91
	; >>>>> switch(dif) { 
	mov	ax, word [NewPieceOrientation]
	sub	ax, word [bp+4]
	mov	word [bp-2], ax
	; >>>>> Line:	91
	; >>>>> switch(dif) { 
	mov	ax, word [bp-2]
	sub	ax, -3
	je	L_lab8app_15
	dec	ax
	je	L_lab8app_16
	dec	ax
	je	L_lab8app_17
	dec	ax
	je	L_lab8app_18
	dec	ax
	je	L_lab8app_19
	dec	ax
	je	L_lab8app_20
	dec	ax
	je	L_lab8app_21
	jmp	L_lab8app_14
L_lab8app_15:
	; >>>>> Line:	93
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	94
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_16:
	; >>>>> Line:	96
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	97
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	98
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_17:
	; >>>>> Line:	100
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	101
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_18:
	; >>>>> Line:	103
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_19:
	; >>>>> Line:	105
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	106
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_20:
	; >>>>> Line:	108
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	109
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	110
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_21:
	; >>>>> Line:	112
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_14:
L_lab8app_13:
	; >>>>> Line:	113
	; >>>>> break; 
L_lab8app_22:
	; >>>>> Line:	118
	; >>>>> return ; 
	mov	sp, bp
	pop	bp
	ret
L_lab8app_11:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_lab8app_12
	ALIGN	2
setColumn:
	; >>>>> Line:	121
	; >>>>> void setColumn(int Column){ 
	jmp	L_lab8app_24
L_lab8app_25:
	; >>>>> Line:	124
	; >>>>> if(NewPieceColumn > Column){ 
	mov	word [bp-2], 0
	; >>>>> Line:	124
	; >>>>> if(NewPieceColumn > Column){ 
	mov	ax, word [NewPieceColumn]
	cmp	ax, word [bp+4]
	jbe	L_lab8app_26
	; >>>>> Line:	125
	; >>>>> dif = NewPieceColumn - Column; 
	mov	ax, word [NewPieceColumn]
	sub	ax, word [bp+4]
	mov	word [bp-4], ax
	; >>>>> Line:	126
	; >>>>> for(i=0;i<dif;i++){ 
	mov	word [bp-2], 0
	jmp	L_lab8app_28
L_lab8app_27:
	; >>>>> Line:	127
	; >>>>> addToQueue(NewPieceID, 0, 0); 
	xor	ax, ax
	push	ax
	xor	ax, ax
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_30:
	inc	word [bp-2]
L_lab8app_28:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-2]
	jg	L_lab8app_27
L_lab8app_29:
	jmp	L_lab8app_31
L_lab8app_26:
	; >>>>> Line:	129
	; >>>>> }else if(NewPieceColumn < Column){ 
	mov	ax, word [NewPieceColumn]
	cmp	ax, word [bp+4]
	jae	L_lab8app_32
	; >>>>> Line:	130
	; >>>>> dif = Column - NewPieceColumn; 
	mov	ax, word [bp+4]
	sub	ax, word [NewPieceColumn]
	mov	word [bp-4], ax
	; >>>>> Line:	131
	; >>>>> for(i=0;i<dif;i++){ 
	mov	word [bp-2], 0
	jmp	L_lab8app_34
L_lab8app_33:
	; >>>>> Line:	132
	; >>>>> addToQueue(NewPi 
	mov	ax, 1
	push	ax
	xor	ax, ax
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_36:
	inc	word [bp-2]
L_lab8app_34:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-2]
	jg	L_lab8app_33
L_lab8app_35:
L_lab8app_32:
L_lab8app_31:
L_lab8app_37:
	; >>>>> Line:	137
	; >>>>> return ; 
	mov	sp, bp
	pop	bp
	ret
L_lab8app_24:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_lab8app_25
L_lab8app_40:
	DB	" D: ",0
L_lab8app_39:
	DB	"C: ",0
	ALIGN	2
SimpCommTask:
	; >>>>> Line:	141
	; >>>>> { 
	jmp	L_lab8app_41
L_lab8app_42:
	; >>>>> Line:	143
	; >>>>> while (1) 
	jmp	L_lab8app_44
L_lab8app_43:
	; >>>>> Line:	145
	; >>>>> YKSemPend(RCSemPtr); 
	push	word [RCSemPtr]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	146
	; >>>>> tmp = (struct msg *) YKQPend(MsgQPtr); 
	push	word [MsgQPtr]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	147
	; >>>>> if(0==1){ 
	jmp	L_lab8app_46
	; >>>>> Line:	148
	; >>>>> printString("C: "); 
	mov	ax, L_lab8app_39
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	149
	; >>>>> printInt(tmp->cmd); 
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	150
	; >>>>> printString(" D: "); 
	mov	ax, L_lab8app_40
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	151
	; >>>>> printInt(tmp->direction); 
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	152
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab8app_46:
	; >>>>> Line:	154
	; >>>>> if(tmp->cmd == 0){ 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [si]
	test	ax, ax
	jne	L_lab8app_47
	; >>>>> Line:	155
	; >>>>> SlidePiece(tmp->pieceID, tmp->direction); 
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	mov	si, word [bp-2]
	push	word [si]
	call	SlidePiece
	add	sp, 4
	jmp	L_lab8app_48
L_lab8app_47:
	; >>>>> Line:	157
	; >>>>> RotatePiece(tmp->pieceID, tmp->direction); 
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	mov	si, word [bp-2]
	push	word [si]
	call	RotatePiece
	add	sp, 4
L_lab8app_48:
L_lab8app_44:
	jmp	L_lab8app_43
L_lab8app_45:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_41:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_lab8app_42
L_lab8app_50:
	DB	"NP NPTSK ",0xD,0xA,0
	ALIGN	2
NewPieceTask:
	; >>>>> Line:	164
	; >>>>> { 
	jmp	L_lab8app_51
L_lab8app_52:
	; >>>>> Line:	172
	; >>>>> while(1){ 
	jmp	L_lab8app_54
L_lab8app_53:
	; >>>>> Line:	173
	; >>>>> bin0B = bin0A; 
	mov	al, byte [bin0A]
	mov	byte [bin0B], al
	; >>>>> Line:	174
	; >>>>> bin1B = bin1A; 
	mov	al, byte [bin1A]
	mov	byte [bin1B], al
	; >>>>> Line:	175
	; >>>>> bin0BL = bin0AL; 
	mov	al, byte [bin0AL]
	mov	byte [bin0BL], al
	; >>>>> Line:	176
	; >>>>> bin1BL = bin1AL; 
	mov	al, byte [bin1AL]
	mov	byte [bin1BL], al
	; >>>>> Line:	177
	; >>>>> if(0==1){ 
	jmp	L_lab8app_56
	; >>>>> Line:	178
	; >>>>> printInt(bin0B); 
	mov	al, byte [bin0B]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	179
	; >>>>> printInt(bin1B); 
	mov	al, byte [bin1B]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	180
	; >>>>> printInt(bin0BL); 
	mov	al, byte [bin0BL]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	181
	; >>>>> printInt(bin1BL); 
	mov	al, byte [bin1BL]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	182
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab8app_56:
	; >>>>> Line:	185
	; >>>>> YKSemPend(NPSemPtr); 
	push	word [NPSemPtr]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	186
	; >>>>> if(0==1){ 
	jmp	L_lab8app_57
	; >>>>> Line:	187
	; >>>>> printString("NP NPTSK \r\n"); 
	mov	ax, L_lab8app_50
	push	ax
	call	printString
	add	sp, 2
L_lab8app_57:
	; >>>>> Line:	192
	; >>>>> if(NewPieceColumn==0){ 
	mov	ax, word [NewPieceColumn]
	test	ax, ax
	jne	L_lab8app_58
	; >>>>> Line:	193
	; >>>>> setColumn(1); 
	mov	ax, 1
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	194
	; >>>>> NewPieceColumn = 1; 
	mov	word [NewPieceColumn], 1
	jmp	L_lab8app_59
L_lab8app_58:
	; >>>>> Line:	195
	; >>>>> }else if(NewPieceColumn==5){ 
	cmp	word [NewPieceColumn], 5
	jne	L_lab8app_60
	; >>>>> Line:	196
	; >>>>> setColumn(4); 
	mov	ax, 4
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	197
	; >>>>> +; 
	mov	word [NewPieceColumn], 4
L_lab8app_60:
L_lab8app_59:
	; >>>>> Line:	200
	; >>>>> if(NewPieceType==1){ 
	cmp	word [NewPieceType], 1
	jne	L_lab8app_61
	; >>>>> Line:	202
	; >>>>> if(NewPieceOrientation==1){ 
	cmp	word [NewPieceOrientation], 1
	jne	L_lab8app_62
	; >>>>> Line:	203
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_62:
	; >>>>> Line:	205
	; >>>>> if(bin0B==0 && bin1B==0){ 
	mov	al, byte [bin0B]
	test	al, al
	jne	L_lab8app_63
	mov	al, byte [bin1B]
	test	al, al
	jne	L_lab8app_63
	; >>>>> Line:	206
	; >>>>> if(bin0BL < bin1BL){ 
	mov	al, byte [bin1BL]
	cmp	al, byte [bin0BL]
	jle	L_lab8app_64
	; >>>>> Line:	207
	; >>>>> setColumn(1); 
	mov	ax, 1
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	208
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	209
	; >>>>> bin0A = 0; 
	mov	byte [bin0A], 0
	jmp	L_lab8app_65
L_lab8app_64:
	; >>>>> Line:	211
	; >>>>> setColumn(4); 
	mov	ax, 4
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	212
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	213
	; >>>>> bin1A = 0; 
	mov	byte [bin1A], 0
L_lab8app_65:
	jmp	L_lab8app_66
L_lab8app_63:
	; >>>>> Line:	217
	; >>>>> if(bin0B==0){ 
	mov	al, byte [bin0B]
	test	al, al
	jne	L_lab8app_67
	; >>>>> Line:	218
	; >>>>> setColumn(1); 
	mov	ax, 1
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	219
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	220
	; >>>>> bin0A = 0; 
	mov	byte [bin0A], 0
	jmp	L_lab8app_68
L_lab8app_67:
	; >>>>> Line:	222
	; >>>>> setColumn(4); 
	mov	ax, 4
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	223
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	224
	; >>>>> in1 
	mov	byte [bin1A], 0
L_lab8app_68:
L_lab8app_66:
	jmp	L_lab8app_69
L_lab8app_61:
	; >>>>> Line:	230
	; >>>>> if((bin0B==0) && (bin1B==0)){ 
	mov	al, byte [bin0B]
	test	al, al
	jne	L_lab8app_70
	mov	al, byte [bin1B]
	test	al, al
	jne	L_lab8app_70
	; >>>>> Line:	231
	; >>>>> if(bin0BL < bin1BL){ 
	mov	al, byte [bin1BL]
	cmp	al, byte [bin0BL]
	jle	L_lab8app_71
	; >>>>> Line:	232
	; >>>>> setOrientation(0); 
	xor	ax, ax
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	233
	; >>>>> setColumn(0); 
	xor	ax, ax
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	234
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	235
	; >>>>> bin0A = 1; 
	mov	byte [bin0A], 1
	jmp	L_lab8app_72
L_lab8app_71:
	; >>>>> Line:	237
	; >>>>> setOrientation(1); 
	mov	ax, 1
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	238
	; >>>>> setColumn(5); 
	mov	ax, 5
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	239
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	240
	; >>>>> bin1A = 1; 
	mov	byte [bin1A], 1
L_lab8app_72:
	jmp	L_lab8app_73
L_lab8app_70:
	; >>>>> Line:	242
	; >>>>> }else if(bin0B != 0){ 
	mov	al, byte [bin0B]
	test	al, al
	je	L_lab8app_74
	; >>>>> Line:	243
	; >>>>> setOrientation(2); 
	mov	ax, 2
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	244
	; >>>>> setColumn(2); 
	mov	ax, 2
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	245
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	246
	; >>>>> bin0A = 0; 
	mov	byte [bin0A], 0
	jmp	L_lab8app_75
L_lab8app_74:
	; >>>>> Line:	248
	; >>>>> setOrientation(3); 
	mov	ax, 3
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	249
	; >>>>> setColumn(3); 
	mov	ax, 3
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	250
	; >>>>> KIdleCount; 
	inc	byte [bin1AL]
	; >>>>> Line:	251
	; >>>>> bin1A = 0; 
	mov	byte [bin1A], 0
L_lab8app_75:
L_lab8app_73:
L_lab8app_69:
L_lab8app_54:
	jmp	L_lab8app_53
L_lab8app_55:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_51:
	push	bp
	mov	bp, sp
	sub	sp, 12
	jmp	L_lab8app_52
L_lab8app_79:
	DB	"% >",0xD,0xA,0
L_lab8app_78:
	DB	", CPU: ",0
L_lab8app_77:
	DB	"<CS: ",0
	ALIGN	2
StatsTask:
	; >>>>> Line:	258
	; >>>>> { 
	jmp	L_lab8app_80
L_lab8app_81:
	; >>>>> Line:	262
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	263
	; >>>>> YKDelayTask(5); 
	mov	ax, 5
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	264
	; >>>>> max = YKIdleCount / 25; 
	mov	ax, word [YKIdleCount]
	cwd
	mov	cx, 25
	idiv	cx
	mov	word [bp-2], ax
	; >>>>> Line:	266
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	268
	; >>>>> YKNewTask(SimpCommTask, (void *) &SimpCommTaskStk[512], 30); 
	mov	al, 30
	push	ax
	mov	ax, (SimpCommTaskStk+1024)
	push	ax
	mov	ax, SimpCommTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	269
	; >>>>> YKNewTask(NewPieceTask, (void *) &NewPieceTaskStk[512], 10); 
	mov	al, 10
	push	ax
	mov	ax, (NewPieceTaskStk+1024)
	push	ax
	mov	ax, NewPieceTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	270
	; >>>>> StartSimptris(); 
	call	StartSimptris
	; >>>>> Line:	272
	; >>>>> while (1) 
	jmp	L_lab8app_83
L_lab8app_82:
	; >>>>> Line:	274
	; >>>>> YKDelayTask(20); 
	mov	ax, 20
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	276
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	277
	; >>>>> switchCount = YKCtxSwCount; 
	mov	ax, word [YKCtxSwCount]
	mov	word [bp-4], ax
	; >>>>> Line:	278
	; >>>>> idleCount = YKIdleCount; 
	mov	ax, word [YKIdleCount]
	mov	word [bp-6], ax
	; >>>>> Line:	279
	; >>>>>  
	call	YKExitMutex
	; >>>>> Line:	281
	; >>>>> printString("<CS: "); 
	mov	ax, L_lab8app_77
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	282
	; >>>>> printInt((int)switchCount); 
	push	word [bp-4]
	call	printInt
	add	sp, 2
	; >>>>> Line:	283
	; >>>>> printString(", CPU: "); 
	mov	ax, L_lab8app_78
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	284
	; >>>>> tmp = (int) (idleCount/max); 
	mov	ax, word [bp-6]
	xor	dx, dx
	div	word [bp-2]
	mov	word [bp-8], ax
	; >>>>> Line:	285
	; >>>>> printInt(100-tmp); 
	mov	ax, 100
	sub	ax, word [bp-8]
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	286
	; >>>>> printString("% >\r\n"); 
	mov	ax, L_lab8app_79
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	288
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	289
	; >>>>> YKCtxSwCount = 0; 
	mov	word [YKCtxSwCount], 0
	; >>>>> Line:	290
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	291
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_lab8app_83:
	jmp	L_lab8app_82
L_lab8app_84:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_80:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_lab8app_81
	ALIGN	2
main:
	; >>>>> Line:	297
	; >>>>> { 
	jmp	L_lab8app_86
L_lab8app_87:
	; >>>>> Line:	298
	; >>>>> YKInitialize(); 
	call	YKInitialize
	; >>>>> Line:	300
	; >>>>> MsgQPtr = YKQCreate(MsgQ, 40); 
	mov	ax, 40
	push	ax
	mov	ax, MsgQ
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [MsgQPtr], ax
	; >>>>> Line:	302
	; >>>>> YKNewTask(StatsTask, (void *) &StatsTaskStk[512], 50); 
	mov	al, 50
	push	ax
	mov	ax, (StatsTaskStk+1024)
	push	ax
	mov	ax, StatsTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	304
	; >>>>> SeedSimptris(10947); 
	mov	ax, 10947
	xor	dx, dx
	push	dx
	push	ax
	call	SeedSimptris
	add	sp, 4
	; >>>>> Line:	306
	; >>>>> NPSemPtr = YKSemCreate(0); 
	xor	ax, ax
	push	ax
	call	YKSemCreate
	add	sp, 2
	mov	word [NPSemPtr], ax
	; >>>>> Line:	307
	; >>>>> RCSemP 
	mov	ax, 1
	push	ax
	call	YKSemCreate
	add	sp, 2
	mov	word [RCSemPtr], ax
	; >>>>> Line:	310
	; >>>>> YKRun(); 
	call	YKRun
	mov	sp, bp
	pop	bp
	ret
L_lab8app_86:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_87
	ALIGN	2
MsgArray:
	TIMES	480 db 0
SimpCommTaskStk:
	TIMES	1024 db 0
NewPieceTaskStk:
	TIMES	1024 db 0
StatsTaskStk:
	TIMES	1024 db 0
MsgQ:
	TIMES	80 db 0
MsgQPtr:
	TIMES	2 db 0
RCSemPtr:
	TIMES	2 db 0
NPSemPtr:
	TIMES	2 db 0
TDSemPtr:
	TIMES	2 db 0
