; Generated by c86 (BYU-NASM) 5.1 (beta) from lab8app.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
nextMsg:
	DW	0
bin0B:
	DB	0
bin1B:
	DB	0
bin0BL:
	DB	0
bin1BL:
	DB	0
bin0A:
	DB	0
bin1A:
	DB	0
bin0AL:
	DB	0
bin1AL:
	DB	0
L_lab8app_3:
	DB	"  addToQ: queue overflow! ",0xA,0
L_lab8app_2:
	DB	" DIR:",0
L_lab8app_1:
	DB	"ATQ: CMD:",0
	ALIGN	2
addToQueue:
	; >>>>> Line:	62
	; >>>>> PieceOrientation - Orientation; 
	jmp	L_lab8app_4
L_lab8app_5:
	; >>>>> Line:	64
	; >>>>> MsgArray[nextMsg].pieceID = pieceID; 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	mov	si, ax
	add	si, MsgArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	65
	; >>>>> MsgArray[nextMsg].cmd = cmd; 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	add	ax, MsgArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	66
	; >>>>> MsgArray[nextMsg].direction = direction; 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	add	ax, MsgArray
	mov	si, ax
	add	si, 4
	mov	ax, word [bp+8]
	mov	word [si], ax
	; >>>>> Line:	67
	; >>>>> if(0==1){ 
	jmp	L_lab8app_6
	; >>>>> Line:	68
	; >>>>> printString("ATQ: CMD:"); 
	mov	ax, L_lab8app_1
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	69
	; >>>>> printInt(cmd); 
	push	word [bp+6]
	call	printInt
	add	sp, 2
	; >>>>> Line:	70
	; >>>>> printString(" DIR:"); 
	mov	ax, L_lab8app_2
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	71
	; >>>>> printInt(direction); 
	push	word [bp+8]
	call	printInt
	add	sp, 2
	; >>>>> Line:	72
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab8app_6:
	; >>>>> Line:	75
	; >>>>> if (YKQPost(MsgQPtr, (void *) &(MsgArray[nextMsg])) == 0) 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	add	ax, MsgArray
	push	ax
	push	word [MsgQPtr]
	call	YKQPost
	add	sp, 4
	test	ax, ax
	jne	L_lab8app_7
	; >>>>> Line:	76
	; >>>>> printString("  addToQ: queue overflow! \n"); 
	mov	ax, L_lab8app_3
	push	ax
	call	printString
	add	sp, 2
	jmp	L_lab8app_8
L_lab8app_7:
	; >>>>> Line:	77
	; >>>>> else if (++nextMsg >= 160) 
	mov	ax, word [nextMsg]
	inc	ax
	mov	word [nextMsg], ax
	cmp	ax, 160
	jl	L_lab8app_9
	; >>>>> Line:	78
	; >>>>> nextMsg = 0; 
	mov	word [nextMsg], 0
L_lab8app_9:
L_lab8app_8:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_4:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_5
	ALIGN	2
setOrientation:
	; >>>>> Line:	82
	; >>>>> void setOrientation(int Orientation){ 
	jmp	L_lab8app_11
L_lab8app_12:
	; >>>>> Line:	85
	; >>>>> switch(di 
	mov	ax, word [NewPieceOrientation]
	sub	ax, word [bp+4]
	mov	word [bp-2], ax
	; >>>>> Line:	85
	; >>>>> switch(di 
	mov	ax, word [bp-2]
	sub	ax, -3
	je	L_lab8app_15
	dec	ax
	je	L_lab8app_16
	dec	ax
	je	L_lab8app_17
	dec	ax
	je	L_lab8app_18
	dec	ax
	je	L_lab8app_19
	dec	ax
	je	L_lab8app_20
	dec	ax
	je	L_lab8app_21
	jmp	L_lab8app_14
L_lab8app_15:
	; >>>>> Line:	87
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	88
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_16:
	; >>>>> Line:	90
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	91
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	92
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_17:
	; >>>>> Line:	94
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	95
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_18:
	; >>>>> Line:	97
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_19:
	; >>>>> Line:	99
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	100
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_20:
	; >>>>> Line:	102
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	103
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	104
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_21:
	; >>>>> Line:	106
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_14:
L_lab8app_13:
	; >>>>> Line:	107
	; >>>>> break; 
L_lab8app_22:
	; >>>>> Line:	112
	; >>>>> return ; 
	mov	sp, bp
	pop	bp
	ret
L_lab8app_11:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_lab8app_12
	ALIGN	2
setColumn:
	; >>>>> Line:	115
	; >>>>> void setColumn(int Column){ 
	jmp	L_lab8app_24
L_lab8app_25:
	; >>>>> Line:	118
	; >>>>> if(NewPieceColumn > Column){ 
	mov	word [bp-2], 0
	; >>>>> Line:	118
	; >>>>> if(NewPieceColumn > Column){ 
	mov	ax, word [NewPieceColumn]
	cmp	ax, word [bp+4]
	jbe	L_lab8app_26
	; >>>>> Line:	119
	; >>>>> dif = NewPieceColumn - Column; 
	mov	ax, word [NewPieceColumn]
	sub	ax, word [bp+4]
	mov	word [bp-4], ax
	; >>>>> Line:	120
	; >>>>> for(i=0;i<dif;i++){ 
	mov	word [bp-2], 0
	jmp	L_lab8app_28
L_lab8app_27:
	; >>>>> Line:	121
	; >>>>> addToQueue(NewPieceID, 0, 0); 
	xor	ax, ax
	push	ax
	xor	ax, ax
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_30:
	inc	word [bp-2]
L_lab8app_28:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-2]
	jg	L_lab8app_27
L_lab8app_29:
	jmp	L_lab8app_31
L_lab8app_26:
	; >>>>> Line:	123
	; >>>>> }else if(NewPieceColumn < Column){ 
	mov	ax, word [NewPieceColumn]
	cmp	ax, word [bp+4]
	jae	L_lab8app_32
	; >>>>> Line:	124
	; >>>>> dif = Column - NewPieceColumn; 
	mov	ax, word [bp+4]
	sub	ax, word [NewPieceColumn]
	mov	word [bp-4], ax
	; >>>>> Line:	125
	; >>>>> for(i=0;i<dif;i++){ 
	mov	word [bp-2], 0
	jmp	L_lab8app_34
L_lab8app_33:
	; >>>>> Line:	126
	; >>>>> addToQueue(NewPieceID, 0, 1); 
	mov	ax, 1
	push	ax
	xor	ax, ax
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_36:
	inc	word [bp-2]
L_lab8app_34:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-2]
	jg	L_lab8app_33
L_lab8app_35:
L_lab8app_32:
L_lab8app_31:
L_lab8app_37:
	; >>>>> Line:	131
	; >>>>> return ; 
	mov	sp, bp
	pop	bp
	ret
L_lab8app_24:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_lab8app_25
L_lab8app_40:
	DB	" D: ",0
L_lab8app_39:
	DB	"C: ",0
	ALIGN	2
SimpCommTask:
	; >>>>> Line:	135
	; >>>>> { 
	jmp	L_lab8app_41
L_lab8app_42:
	; >>>>> Line:	137
	; >>>>> while (1) 
	jmp	L_lab8app_44
L_lab8app_43:
	; >>>>> Line:	139
	; >>>>> YKSemPend(RCSemPtr); 
	push	word [RCSemPtr]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	140
	; >>>>> tmp = (struct msg *) YKQPend(MsgQPtr); 
	push	word [MsgQPtr]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	141
	; >>>>> if(0==1){ 
	jmp	L_lab8app_46
	; >>>>> Line:	142
	; >>>>> printString("C: "); 
	mov	ax, L_lab8app_39
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	143
	; >>>>>  
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	144
	; >>>>> printString(" D: "); 
	mov	ax, L_lab8app_40
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	145
	; >>>>> printInt(tmp->direction); 
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	146
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab8app_46:
	; >>>>> Line:	148
	; >>>>> if(tmp->cmd == 0){ 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [si]
	test	ax, ax
	jne	L_lab8app_47
	; >>>>> Line:	149
	; >>>>> SlidePiece(tmp->pieceID, tmp->direction); 
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	mov	si, word [bp-2]
	push	word [si]
	call	SlidePiece
	add	sp, 4
	jmp	L_lab8app_48
L_lab8app_47:
	; >>>>> Line:	151
	; >>>>> RotatePiece(tmp->pieceID, tmp->direction); 
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	mov	si, word [bp-2]
	push	word [si]
	call	RotatePiece
	add	sp, 4
L_lab8app_48:
L_lab8app_44:
	jmp	L_lab8app_43
L_lab8app_45:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_41:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_lab8app_42
L_lab8app_50:
	DB	"NP NPTSK ",0xD,0xA,0
	ALIGN	2
NewPieceTask:
	; >>>>> Line:	158
	; >>>>> { 
	jmp	L_lab8app_51
L_lab8app_52:
	; >>>>> Line:	160
	; >>>>> while(1){ 
	jmp	L_lab8app_54
L_lab8app_53:
	; >>>>> Line:	161
	; >>>>> bin0B = bin0A; 
	mov	al, byte [bin0A]
	mov	byte [bin0B], al
	; >>>>> Line:	162
	; >>>>> bin1B = bin1A; 
	mov	al, byte [bin1A]
	mov	byte [bin1B], al
	; >>>>> Line:	163
	; >>>>> bin0BL = bin0AL; 
	mov	al, byte [bin0AL]
	mov	byte [bin0BL], al
	; >>>>> Line:	164
	; >>>>> bin1BL = bin1AL; 
	mov	al, byte [bin1AL]
	mov	byte [bin1BL], al
	; >>>>> Line:	165
	; >>>>> if(0==1){ 
	jmp	L_lab8app_56
	; >>>>> Line:	166
	; >>>>> printInt(bin0B); 
	mov	al, byte [bin0B]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	167
	; >>>>> printInt(bin1B); 
	mov	al, byte [bin1B]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	168
	; >>>>> printInt(bin0BL); 
	mov	al, byte [bin0BL]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	169
	; >>>>> printInt(bin1BL); 
	mov	al, byte [bin1BL]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	170
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab8app_56:
	; >>>>> Line:	173
	; >>>>> e{ 
	push	word [NPSemPtr]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	174
	; >>>>> if(0==1){ 
	jmp	L_lab8app_57
	; >>>>> Line:	175
	; >>>>> printString("NP NPTSK \r\n"); 
	mov	ax, L_lab8app_50
	push	ax
	call	printString
	add	sp, 2
L_lab8app_57:
	; >>>>> Line:	180
	; >>>>> if(NewPieceColumn==0){ 
	mov	ax, word [NewPieceColumn]
	test	ax, ax
	jne	L_lab8app_58
	; >>>>> Line:	181
	; >>>>> setColumn(1); 
	mov	ax, 1
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	182
	; >>>>> NewPieceColumn = 1; 
	mov	word [NewPieceColumn], 1
	jmp	L_lab8app_59
L_lab8app_58:
	; >>>>> Line:	183
	; >>>>> }else if(NewPieceColumn==5){ 
	cmp	word [NewPieceColumn], 5
	jne	L_lab8app_60
	; >>>>> Line:	184
	; >>>>> setColumn(4); 
	mov	ax, 4
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	185
	; >>>>> NewPieceColumn = 4; 
	mov	word [NewPieceColumn], 4
L_lab8app_60:
L_lab8app_59:
	; >>>>> Line:	188
	; >>>>> if(NewPieceType==1){ 
	cmp	word [NewPieceType], 1
	jne	L_lab8app_61
	; >>>>> Line:	190
	; >>>>> if(NewPieceOrientation==1){ 
	cmp	word [NewPieceOrientation], 1
	jne	L_lab8app_62
	; >>>>> Line:	191
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_62:
	; >>>>> Line:	193
	; >>>>> if(bin0B==0){ 
	mov	al, byte [bin0B]
	test	al, al
	jne	L_lab8app_63
	; >>>>> Line:	194
	; >>>>> if(bin1B==0){ 
	mov	al, byte [bin1B]
	test	al, al
	jne	L_lab8app_64
	; >>>>> Line:	195
	; >>>>> if(bin0BL < bin1BL){ 
	mov	al, byte [bin1BL]
	cmp	al, byte [bin0BL]
	jle	L_lab8app_65
	; >>>>> Line:	196
	; >>>>> setColumn(1); 
	mov	ax, 1
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	197
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	198
	; >>>>> bin0A = 0; 
	mov	byte [bin0A], 0
	jmp	L_lab8app_66
L_lab8app_65:
	; >>>>> Line:	200
	; >>>>> mn(5); 
	mov	ax, 4
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	201
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	202
	; >>>>> bin1A = 0; 
	mov	byte [bin1A], 0
L_lab8app_66:
	jmp	L_lab8app_67
L_lab8app_64:
	; >>>>> Line:	206
	; >>>>> setColumn(1); 
	mov	ax, 1
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	207
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	208
	; >>>>> bin0A = 0; 
	mov	byte [bin0A], 0
L_lab8app_67:
	jmp	L_lab8app_68
L_lab8app_63:
	; >>>>> Line:	211
	; >>>>> setColumn(4); 
	mov	ax, 4
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	212
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	213
	; >>>>> bin1A = 0; 
	mov	byte [bin1A], 0
L_lab8app_68:
	jmp	L_lab8app_69
L_lab8app_61:
	; >>>>> Line:	218
	; >>>>> if((bin0B==0)){ 
	mov	al, byte [bin0B]
	test	al, al
	jne	L_lab8app_70
	; >>>>> Line:	219
	; >>>>> if(bin1B==0){ 
	mov	al, byte [bin1B]
	test	al, al
	jne	L_lab8app_71
	; >>>>> Line:	220
	; >>>>> if(bin0BL < bin1BL){ 
	mov	al, byte [bin1BL]
	cmp	al, byte [bin0BL]
	jle	L_lab8app_72
	; >>>>> Line:	221
	; >>>>> setOrientation(0); 
	xor	ax, ax
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	222
	; >>>>> setColumn(0); 
	xor	ax, ax
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	223
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	224
	; >>>>> bin0A = 1; 
	mov	byte [bin0A], 1
	jmp	L_lab8app_73
L_lab8app_72:
	; >>>>> Line:	226
	; >>>>> setOrientation(1); 
	mov	ax, 1
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	227
	; >>>>> setColumn(5); 
	mov	ax, 5
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	228
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	229
	; >>>>> bin1A = 1; 
	mov	byte [bin1A], 1
L_lab8app_73:
	jmp	L_lab8app_74
L_lab8app_71:
	; >>>>> Line:	232
	; >>>>> setOrientation(3); 
	mov	ax, 3
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	233
	; >>>>> setColumn(3); 
	mov	ax, 3
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	234
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	235
	; >>>>> bin1A = 0; 
	mov	byte [bin1A], 0
L_lab8app_74:
	jmp	L_lab8app_75
L_lab8app_70:
	; >>>>> Line:	238
	; >>>>> setOrientation(2); 
	mov	ax, 2
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	239
	; >>>>> setColumn(2); 
	mov	ax, 2
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	240
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	241
	; >>>>> bin0A = 0; 
	mov	byte [bin0A], 0
L_lab8app_75:
L_lab8app_69:
L_lab8app_54:
	jmp	L_lab8app_53
L_lab8app_55:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_51:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_52
L_lab8app_79:
	DB	"%>",0xD,0xA,0
L_lab8app_78:
	DB	", CPU: ",0
L_lab8app_77:
	DB	"<CS: ",0
	ALIGN	2
StatsTask:
	; >>>>> Line:	248
	; >>>>> { 
	jmp	L_lab8app_80
L_lab8app_81:
	; >>>>> Line:	252
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	253
	; >>>>> YKDelayTask(5); 
	mov	ax, 5
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	254
	; >>>>> max = YKIdleCount / 25; 
	mov	ax, word [YKIdleCount]
	cwd
	mov	cx, 25
	idiv	cx
	mov	word [bp-2], ax
	; >>>>> Line:	256
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	258
	; >>>>> YKNewTask(SimpCommTask, (void *) &SimpCo 
	mov	al, 5
	push	ax
	mov	ax, (SimpCommTaskStk+1024)
	push	ax
	mov	ax, SimpCommTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	259
	; >>>>> YKNewTask(NewPieceTask, (void *) &NewPieceTaskStk[512], 10); 
	mov	al, 10
	push	ax
	mov	ax, (NewPieceTaskStk+1024)
	push	ax
	mov	ax, NewPieceTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	260
	; >>>>> StartSimptris(); 
	call	StartSimptris
	; >>>>> Line:	262
	; >>>>> while (1) 
	jmp	L_lab8app_83
L_lab8app_82:
	; >>>>> Line:	264
	; >>>>> YKDelayTask(20); 
	mov	ax, 20
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	266
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	267
	; >>>>> switchCount = YKCtxSwCount; 
	mov	ax, word [YKCtxSwCount]
	mov	word [bp-4], ax
	; >>>>> Line:	268
	; >>>>> idleCount = YKIdleCount; 
	mov	ax, word [YKIdleCount]
	mov	word [bp-6], ax
	; >>>>> Line:	269
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	271
	; >>>>> printString("<CS: "); 
	mov	ax, L_lab8app_77
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	272
	; >>>>> printInt((int)switchCount); 
	push	word [bp-4]
	call	printInt
	add	sp, 2
	; >>>>> Line:	273
	; >>>>> printString(", CPU: "); 
	mov	ax, L_lab8app_78
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	274
	; >>>>> tmp = (int) (idleCount/max); 
	mov	ax, word [bp-6]
	xor	dx, dx
	div	word [bp-2]
	mov	word [bp-8], ax
	; >>>>> Line:	275
	; >>>>> printInt(100-tmp); 
	mov	ax, 100
	sub	ax, word [bp-8]
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	276
	; >>>>> printString("%>\r\n"); 
	mov	ax, L_lab8app_79
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	278
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	279
	; >>>>> YKCtxSwCount = 0 
	mov	word [YKCtxSwCount], 0
	; >>>>> Line:	280
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	281
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_lab8app_83:
	jmp	L_lab8app_82
L_lab8app_84:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_80:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_lab8app_81
	ALIGN	2
main:
	; >>>>> Line:	287
	; >>>>> { 
	jmp	L_lab8app_86
L_lab8app_87:
	; >>>>> Line:	288
	; >>>>> YKInitialize(); 
	call	YKInitialize
	; >>>>> Line:	290
	; >>>>> MsgQPtr = YKQCreate(MsgQ, 80); 
	mov	ax, 80
	push	ax
	mov	ax, MsgQ
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [MsgQPtr], ax
	; >>>>> Line:	292
	; >>>>> YKNewTask(StatsTask, (void *) &StatsTaskStk[512], 50); 
	mov	al, 50
	push	ax
	mov	ax, (StatsTaskStk+1024)
	push	ax
	mov	ax, StatsTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	294
	; >>>>> SeedSimptris(0xDEADBEEF); 
	mov	ax, 48879
	mov	dx, 57005
	push	dx
	push	ax
	call	SeedSimptris
	add	sp, 4
	; >>>>> Line:	296
	; >>>>> NPSemPtr = YKSemCreate(0); 
	xor	ax, ax
	push	ax
	call	YKSemCreate
	add	sp, 2
	mov	word [NPSemPtr], ax
	; >>>>> Line:	297
	; >>>>> RCSemPtr = YKSemCreate(1); 
	mov	ax, 1
	push	ax
	call	YKSemCreate
	add	sp, 2
	mov	word [RCSemPtr], ax
	; >>>>> Line:	300
	; >>>>> YKRun(); 
	call	YKRun
	mov	sp, bp
	pop	bp
	ret
L_lab8app_86:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_87
	ALIGN	2
MsgArray:
	TIMES	960 db 0
SimpCommTaskStk:
	TIMES	1024 db 0
NewPieceTaskStk:
	TIMES	1024 db 0
StatsTaskStk:
	TIMES	1024 db 0
MsgQ:
	TIMES	160 db 0
MsgQPtr:
	TIMES	2 db 0
RCSemPtr:
	TIMES	2 db 0
NPSemPtr:
	TIMES	2 db 0
