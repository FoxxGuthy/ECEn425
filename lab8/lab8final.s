        CPU     8086
        ORG     0h
InterruptVectorTable:
        ; Internal x86 Interrupts:
        dd      0 ; Reserved (Div err)  ; Int 00h
        dd      0 ; Reserved (Step)     ; Int 01h
        dd      0 ; Reserved (NMI)      ; Int 02h
        dd      0 ; Reserved (Break)    ; Int 03h
        dd      0 ; Reserved (Overflow) ; Int 04h
        dd      0                       ; Int 05h
        dd      0                       ; Int 06h
        dd      0                       ; Int 07h
        ; Hardware Interrupts:
        dd      resetISR ; Reset                          ; Int 08h (IRQ 0)		; CHANGED
        dd      tickISR	 ; Tick                           ; Int 09h (IRQ 1)		; CHANGED
        dd      kbISR	 ; Keyboard                         ; Int 0Ah (IRQ 2)		; CHANGED
        dd      gameOverISR ; Simptris Game Over          ; Int 0Bh (IRQ 3)
        dd      newPieceISR ; Simptris New Piece          ; Int 0Ch (IRQ 4)
        dd      receivedCommandISR ; Simptris Received    ; Int 0Dh (IRQ 5)
        dd      touchdownISR ; Simptris Touchdown         ; Int 0Eh (IRQ 6)
        dd      lineclearISR ; Simptris Clear             ; Int 0Fh (IRQ 7)
        ; Software Interrupts:
        dd      0 ; Reserved (PC BIOS)  ; Int 10h
        dd      0                       ; Int 11h
        dd      0                       ; Int 12h
        dd      0                       ; Int 13h
        dd      0                       ; Int 14h
        dd      0                       ; Int 15h
        dd      0                       ; Int 16h
        dd      0                       ; Int 17h
        dd      0                       ; Int 18h
        dd      0                       ; Int 19h
        dd      0                       ; Int 1Ah
        dd      0                       ; Int 1Bh
        dd      0                       ; Int 1Ch
        dd      0                       ; Int 1Dh
        dd      0                       ; Int 1Eh
        dd      0                       ; Int 1Fh
        dd      0                       ; Int 20h
        dd      0 ; Reserved (DOS)      ; Int 21h
        dd      0 ; Simptris Services   ; Int 22h
        dd      0                       ; Int 23h
        dd      0                       ; Int 24h
        dd      0                       ; Int 25h
        dd      0                       ; Int 26h
        dd      0                       ; Int 27h
        dd      0                       ; Int 28h
        dd      0                       ; Int 29h
        dd      0                       ; Int 2Ah
        dd      0                       ; Int 2Bh
        dd      0                       ; Int 2Ch
        dd      0                       ; Int 2Dh
        dd      0                       ; Int 2Eh
        dd      0                       ; Int 2Fh
KeyBuffer:                              ; Address 0xC0
        dw      0
NewPieceType:                           ; Address 0xC2
        dw      0
NewPieceID:                             ; Address 0xC4
        dw      0
NewPieceOrientation:                    ; Address 0xC6
        dw      0
NewPieceColumn:                         ; Address 0xC8
        dw      0
TouchdownID:                            ; Address 0xCA
	dw	0
ScreenBitMap0:                          ; Address 0xCC
        dw      0
ScreenBitMap1:
        dw      0
ScreenBitMap2:
        dw      0
ScreenBitMap3:
        dw      0
ScreenBitMap4:
        dw      0
ScreenBitMap5:
        dw      0
TIMES   100h-($-$$) db  0               ; Fill up to (but not including) address 100h with 0
	jmp	main
; This file contains support routines for 32-bit on the 8086.
; It is intended for use code generated by the C86 compiler.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SR_asldiv:			; l1 /= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_ldiv
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslmod:			; l1 %= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lmod
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslmul:			; l1 *= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lmul
	add	sp,8
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslshl:			; l1 <<= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lshl
	add	sp,8
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslshr:			; l1 >>= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lshr
	add	sp,8
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret


SR_asuldiv:			; u1 /= u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_uldiv
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asilmod:			; u1 %= u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ilmod
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asulmul:			; u1 *= u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ulmul
	add	sp,8
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asulshl:			; u1 << u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ulshl
	add	sp,8
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asulshr:			; u1 >> u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ulshr
	add	sp,8
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret


; Main 32-bit routines begin here:

SR_ldiv:	; N_LDIV@
	pop    cx
	push   cs
	push   cx
	; LDIV@
	xor    cx,cx
	jmp    LSR_01
SR_uldiv:	; N_LUDIV@
	pop    cx
	push   cs
	push   cx
	; F_LUDIV@
	mov    cx,0001
	jmp    LSR_01
SR_lmod:	; N_LMOD@
	pop    cx
	push   cs
	push   cx
	; F_LMOD@
	mov    cx,0002
	jmp    LSR_01
SR_ilmod:	; N_LUMOD@
	pop    cx
	push   cs
	push   cx
	; LUMOD@
	mov    cx,0003
LSR_01:
	push   bp
	push   si
	push   di
	mov    bp,sp
	mov    di,cx
	mov    ax,[bp+0Ah]
	mov    dx,[bp+0Ch]
	mov    bx,[bp+0Eh]
	mov    cx,[bp+10h]
	or     cx,cx
	jne    LSR_02
	or     dx,dx
	je     LSR_10
	or     bx,bx
	je     LSR_10
LSR_02:
	test   di,0001
	jne    LSR_04
	or     dx,dx
	jns    LSR_03
	neg    dx
	neg    ax
	sbb    dx,0000
	or     di,000Ch
LSR_03:
	or     cx,cx
	jns    LSR_04
	neg    cx
	neg    bx
	sbb    cx,0000
	xor    di,0004
LSR_04:
	mov    bp,cx
	mov    cx,0020h
	push   di
	xor    di,di
	xor    si,si
LSR_05:
	shl    ax,1
	rcl    dx,1
	rcl    si,1
	rcl    di,1
	cmp    di,bp
	jb     LSR_07
	ja     LSR_06
	cmp    si,bx
	jb     LSR_07
LSR_06:
	sub    si,bx
	sbb    di,bp
	inc    ax
LSR_07:
	loop   LSR_05
	pop    bx
	test   bx,0002
	je     LSR_08
	mov    ax,si
	mov    dx,di
	shr    bx,1
LSR_08:
	test   bx,0004h
	je     LSR_09
	neg    dx
	neg    ax
	sbb    dx,0000
LSR_09:
	pop    di
	pop    si
	pop    bp
	retf   0008
LSR_10:
	div    bx
	test   di,0002
	je     LSR_11
	xchg   dx,ax
LSR_11:
	xor    dx,dx
	jmp    LSR_09
SR_lshl:	; N_LXLSH@
SR_ulshl:
	; r = a << b
	pop    bx
	push   cs
	push   bx

	push   bp
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx

	mov    ax, [bp+6]	; pop loword(a)
	mov    dx, [bp+8]	; pop hiword(a)
	mov    cx, [bp+10]	; pop word(b)

	; LXLSH@
	cmp    cl,10h
	jnb    LSR_12
	mov    bx,ax
	shl    ax,cl
	shl    dx,cl
	neg    cl
	add    cl,10h
	shr    bx,cl
	or     dx,bx
	pop    cx
	pop    bp
	retf
LSR_12:
	sub    cl,10h
	xchg   dx,ax
	xor    ax,ax
	shl    dx,cl
	pop    cx
	pop    bp
	retf
SR_lshr:	; N_LXRSH@
	; r = a >> b
	pop    bx
	push   cs
	push   bx

	push   bp
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx

        mov    ax, [bp+6]	; pop loword(a)
	mov    dx, [bp+8]	; pop hiword(a)
	mov    cx, [bp+10]	; pop word(b)

	; LXRSH@
	cmp    cl,10h
	jnb    LSR_13
	mov    bx,dx
	shr    ax,cl
	sar    dx,cl
	neg    cl
	add    cl,10h
	shl    bx,cl
	or     ax,bx
	pop    cx
	pop    bp
	retf
LSR_13:
	sub    cl,10h
	xchg   dx,ax
	cwd
	sar    ax,cl
	pop    cx
	pop    bp
	retf
SR_ulshr:	; N_LXURSH@
	; r = a >> b
	pop    bx
	push   cs
	push   bx

	push   bp
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx

        mov    ax, [bp+6]	; pop loword(a)
	mov    dx, [bp+8]	; pop hiword(a)
	mov    cx, [bp+10]	; pop word(b)

	; LXURSH@
	cmp    cl,10h
	jnb    LSR_14
	mov    bx,dx
	shr    ax,cl
	shr    dx,cl
	neg    cl
	add    cl,10h
	shl    bx,cl
	or     ax,bx
	pop    cx
	pop    bp
	retf
LSR_14:
	sub    cl,10h
	xchg   dx,ax
	xor    dx,dx
	shr    ax,cl
	pop    cx
	pop    bp
	retf
SR_lmul:	; N_LXMUL@
SR_ulmul:
	; r = a * b
	push   bp
	push   si
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx
	push   bx

        mov    bx, [bp+6]	; pop loword(a)
	mov    cx, [bp+8]	; pop hiword(a)
	mov    ax, [bp+10]	; pop loword(b)
	mov    dx, [bp+12]	; pop hiword(b)

	xchg   si,ax
	xchg   dx,ax
	test   ax,ax
	je     LSR_15
	mul    bx
LSR_15:
	jcxz   LSR_16
	xchg   cx,ax
	mul    si
	add    ax,cx
LSR_16:
	xchg   si,ax
	mul    bx
	add    dx,si
	pop    bx
	pop    cx
	pop    si
	pop    bp
	ret

; Generated by c86 (BYU-NASM) 5.1 (beta) from clib.c
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
new_line:
	db	13,10,36
	ALIGN	2
signalEOI:
	jmp	L_clib_1
L_clib_2:
	mov	al, 0x20
	out	0x20, al
	mov	sp, bp
	pop	bp
	ret
L_clib_1:
	push	bp
	mov	bp, sp
	jmp	L_clib_2
	ALIGN	2
exit:
	jmp	L_clib_4
L_clib_5:
	mov	ah, 4Ch
	mov	al, [bp+4]
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_4:
	push	bp
	mov	bp, sp
	jmp	L_clib_5
	ALIGN	2
print:
	jmp	L_clib_7
L_clib_8:
	mov	ah, 40h
	mov	bx, 1
	mov	cx, [bp+6]
	mov	dx, [bp+4]
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_7:
	push	bp
	mov	bp, sp
	jmp	L_clib_8
	ALIGN	2
printChar:
	jmp	L_clib_10
L_clib_11:
	mov	ah, 2
	mov	dl, [bp+4]
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_10:
	push	bp
	mov	bp, sp
	jmp	L_clib_11
	ALIGN	2
printNewLine:
	jmp	L_clib_13
L_clib_14:
	mov	ah, 9
	mov	dx, new_line
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_13:
	push	bp
	mov	bp, sp
	jmp	L_clib_14
	ALIGN	2
printString:
	jmp	L_clib_16
L_clib_17:
	xor	si,si
	mov	bx, [bp+4]
	jmp	printString2
	printString1:
	inc	si
	printString2:
	cmp	byte [bx+si],0
	jne	printString1
	mov	dx, bx
	mov	cx, si
	mov	ah, 40h
	mov	bx, 1
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_16:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_clib_17
	ALIGN	2
printInt:
	jmp	L_clib_19
L_clib_20:
	mov	word [bp-2], 0
	mov	word [bp-4], 10000
	cmp	word [bp+4], 0
	jge	L_clib_21
	mov	byte [bp-10], 45
	inc	word [bp-2]
	mov	ax, word [bp+4]
	neg	ax
	mov	word [bp+4], ax
L_clib_21:
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_clib_22
	mov	word [bp-4], 1
	jmp	L_clib_23
L_clib_22:
	jmp	L_clib_25
L_clib_24:
	mov	ax, word [bp-4]
	cwd
	mov	cx, 10
	idiv	cx
	mov	word [bp-4], ax
L_clib_25:
	mov	ax, word [bp+4]
	cwd
	idiv	word [bp-4]
	test	ax, ax
	je	L_clib_24
L_clib_26:
L_clib_23:
	jmp	L_clib_28
L_clib_27:
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-10]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	mov	ax, dx
	mov	word [bp+4], ax
	mov	ax, word [bp-4]
	cwd
	mov	cx, 10
	idiv	cx
	mov	word [bp-4], ax
	mov	ax, word [bp-4]
	mov	word [bp-4], ax
L_clib_28:
	cmp	word [bp-4], 0
	jg	L_clib_27
L_clib_29:
	push	word [bp-2]
	lea	ax, [bp-10]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_19:
	push	bp
	mov	bp, sp
	sub	sp, 10
	jmp	L_clib_20
	ALIGN	2
printLong:
	jmp	L_clib_31
L_clib_32:
	mov	word [bp-2], 0
	mov	word [bp-6], 51712
	mov	word [bp-4], 15258
	cmp	word [bp+6], 0
	jg	L_clib_33
	jl	L_clib_34
	cmp	word [bp+4], 0
	jae	L_clib_33
L_clib_34:
	mov	byte [bp-17], 45
	inc	word [bp-2]
	mov	ax, word [bp+4]
	mov	dx, word [bp+6]
	neg	ax
	adc	dx, 0
	neg	dx
	mov	word [bp+4], ax
	mov	word [bp+6], dx
L_clib_33:
	mov	ax, word [bp+4]
	mov	dx, word [bp+6]
	or	dx, ax
	jne	L_clib_35
	mov	word [bp-6], 1
	mov	word [bp-4], 0
	jmp	L_clib_36
L_clib_35:
	jmp	L_clib_38
L_clib_37:
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asldiv
L_clib_38:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_ldiv
	or	dx, ax
	je	L_clib_37
L_clib_39:
L_clib_36:
	jmp	L_clib_41
L_clib_40:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_uldiv
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-17]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_lmod
	mov	word [bp+4], ax
	mov	word [bp+6], dx
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asldiv
L_clib_41:
	cmp	word [bp-4], 0
	jg	L_clib_40
	jne	L_clib_43
	cmp	word [bp-6], 0
	ja	L_clib_40
L_clib_43:
L_clib_42:
	push	word [bp-2]
	lea	ax, [bp-17]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_31:
	push	bp
	mov	bp, sp
	sub	sp, 18
	jmp	L_clib_32
	ALIGN	2
printUInt:
	jmp	L_clib_45
L_clib_46:
	mov	word [bp-2], 0
	mov	word [bp-4], 10000
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_clib_47
	mov	word [bp-4], 1
	jmp	L_clib_48
L_clib_47:
	jmp	L_clib_50
L_clib_49:
	mov	ax, word [bp-4]
	xor	dx, dx
	mov	cx, 10
	div	cx
	mov	word [bp-4], ax
L_clib_50:
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	test	ax, ax
	je	L_clib_49
L_clib_51:
L_clib_48:
	jmp	L_clib_53
L_clib_52:
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-10]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	mov	word [bp+4], dx
	mov	ax, word [bp-4]
	xor	dx, dx
	mov	cx, 10
	div	cx
	mov	word [bp-4], ax
L_clib_53:
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_clib_52
L_clib_54:
	push	word [bp-2]
	lea	ax, [bp-10]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_45:
	push	bp
	mov	bp, sp
	sub	sp, 10
	jmp	L_clib_46
	ALIGN	2
printULong:
	jmp	L_clib_56
L_clib_57:
	mov	word [bp-2], 0
	mov	word [bp-6], 51712
	mov	word [bp-4], 15258
	mov	ax, word [bp+4]
	mov	dx, word [bp+6]
	or	dx, ax
	jne	L_clib_58
	mov	word [bp-6], 1
	mov	word [bp-4], 0
	jmp	L_clib_59
L_clib_58:
	jmp	L_clib_61
L_clib_60:
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asuldiv
L_clib_61:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_uldiv
	or	dx, ax
	je	L_clib_60
L_clib_62:
L_clib_59:
	jmp	L_clib_64
L_clib_63:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_uldiv
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-17]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	push	word [bp-4]
	push	word [bp-6]
	lea	ax, [bp+4]
	push	ax
	call	SR_asilmod
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asuldiv
L_clib_64:
	mov	ax, word [bp-6]
	mov	dx, word [bp-4]
	or	dx, ax
	jne	L_clib_63
L_clib_65:
	push	word [bp-2]
	lea	ax, [bp-17]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_56:
	push	bp
	mov	bp, sp
	sub	sp, 18
	jmp	L_clib_57
	ALIGN	2
printByte:
	jmp	L_clib_67
L_clib_68:
	mov	al, byte [bp+4]
	cbw
	mov	cx, 4
	sar	ax, cl
	and	ax, 15
	mov	byte [bp-1], al
	cmp	byte [bp-1], 9
	jle	L_clib_69
	mov	al, byte [bp-1]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_70
L_clib_69:
	mov	al, byte [bp-1]
	cbw
	add	ax, 48
L_clib_70:
	mov	byte [bp-3], al
	mov	al, byte [bp+4]
	and	al, 15
	mov	byte [bp-1], al
	cmp	byte [bp-1], 9
	jle	L_clib_71
	mov	al, byte [bp-1]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_72
L_clib_71:
	mov	al, byte [bp-1]
	cbw
	add	ax, 48
L_clib_72:
	mov	byte [bp-2], al
	mov	ax, 2
	push	ax
	lea	ax, [bp-3]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_67:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_clib_68
	ALIGN	2
printWord:
	jmp	L_clib_74
L_clib_75:
	mov	word [bp-2], 3
	jmp	L_clib_77
L_clib_76:
	mov	ax, word [bp+4]
	and	ax, 15
	mov	byte [bp-3], al
	cmp	byte [bp-3], 9
	jle	L_clib_80
	mov	al, byte [bp-3]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_81
L_clib_80:
	mov	al, byte [bp-3]
	cbw
	add	ax, 48
L_clib_81:
	mov	si, word [bp-2]
	lea	dx, [bp-7]
	add	si, dx
	mov	byte [si], al
	mov	ax, word [bp+4]
	mov	cx, 4
	sar	ax, cl
	mov	word [bp+4], ax
L_clib_79:
	dec	word [bp-2]
L_clib_77:
	cmp	word [bp-2], 0
	jge	L_clib_76
L_clib_78:
	mov	ax, 4
	push	ax
	lea	ax, [bp-7]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_74:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_clib_75
	ALIGN	2
printDWord:
	jmp	L_clib_83
L_clib_84:
	lea	ax, [bp+4]
	mov	si, ax
	mov	ax, word [si]
	mov	word [bp-6], ax
	lea	ax, [bp+4]
	mov	si, ax
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-8], ax
	mov	word [bp-2], 3
	jmp	L_clib_86
L_clib_85:
	mov	ax, word [bp-6]
	and	ax, 15
	mov	byte [bp-3], al
	cmp	byte [bp-3], 9
	jle	L_clib_89
	mov	al, byte [bp-3]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_90
L_clib_89:
	mov	al, byte [bp-3]
	cbw
	add	ax, 48
L_clib_90:
	mov	dx, word [bp-2]
	add	dx, 4
	mov	si, dx
	lea	dx, [bp-16]
	add	si, dx
	mov	byte [si], al
	mov	ax, word [bp-6]
	mov	cx, 4
	sar	ax, cl
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	and	ax, 15
	mov	byte [bp-3], al
	cmp	byte [bp-3], 9
	jle	L_clib_91
	mov	al, byte [bp-3]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_92
L_clib_91:
	mov	al, byte [bp-3]
	cbw
	add	ax, 48
L_clib_92:
	mov	si, word [bp-2]
	lea	dx, [bp-16]
	add	si, dx
	mov	byte [si], al
	mov	ax, word [bp-8]
	mov	cx, 4
	sar	ax, cl
	mov	word [bp-8], ax
L_clib_88:
	dec	word [bp-2]
L_clib_86:
	cmp	word [bp-2], 0
	jge	L_clib_85
L_clib_87:
	mov	ax, 8
	push	ax
	lea	ax, [bp-16]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_83:
	push	bp
	mov	bp, sp
	sub	sp, 16
	jmp	L_clib_84
; Generated by c86 (BYU-NASM) 5.1 (beta) from lab8app.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
nextMsg:
	DW	0
bin0B:
	DB	0
bin1B:
	DB	0
bin0BL:
	DB	0
bin1BL:
	DB	0
bin0A:
	DB	0
bin1A:
	DB	0
bin0AL:
	DB	0
bin1AL:
	DB	0
L_lab8app_3:
	DB	"  addToQ: queue overflow! ",0xA,0
L_lab8app_2:
	DB	" DIR:",0
L_lab8app_1:
	DB	"ATQ: CMD:",0
	ALIGN	2
addToQueue:
	; >>>>> Line:	62
	; >>>>> PieceOrientation - Orientation; 
	jmp	L_lab8app_4
L_lab8app_5:
	; >>>>> Line:	64
	; >>>>> MsgArray[nextMsg].pieceID = pieceID; 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	mov	si, ax
	add	si, MsgArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	65
	; >>>>> MsgArray[nextMsg].cmd = cmd; 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	add	ax, MsgArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	66
	; >>>>> MsgArray[nextMsg].direction = direction; 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	add	ax, MsgArray
	mov	si, ax
	add	si, 4
	mov	ax, word [bp+8]
	mov	word [si], ax
	; >>>>> Line:	67
	; >>>>> if(0==1){ 
	jmp	L_lab8app_6
	; >>>>> Line:	68
	; >>>>> printString("ATQ: CMD:"); 
	mov	ax, L_lab8app_1
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	69
	; >>>>> printInt(cmd); 
	push	word [bp+6]
	call	printInt
	add	sp, 2
	; >>>>> Line:	70
	; >>>>> printString(" DIR:"); 
	mov	ax, L_lab8app_2
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	71
	; >>>>> printInt(direction); 
	push	word [bp+8]
	call	printInt
	add	sp, 2
	; >>>>> Line:	72
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab8app_6:
	; >>>>> Line:	75
	; >>>>> if (YKQPost(MsgQPtr, (void *) &(MsgArray[nextMsg])) == 0) 
	mov	ax, word [nextMsg]
	mov	cx, 6
	imul	cx
	add	ax, MsgArray
	push	ax
	push	word [MsgQPtr]
	call	YKQPost
	add	sp, 4
	test	ax, ax
	jne	L_lab8app_7
	; >>>>> Line:	76
	; >>>>> printString("  addToQ: queue overflow! \n"); 
	mov	ax, L_lab8app_3
	push	ax
	call	printString
	add	sp, 2
	jmp	L_lab8app_8
L_lab8app_7:
	; >>>>> Line:	77
	; >>>>> else if (++nextMsg >= 160) 
	mov	ax, word [nextMsg]
	inc	ax
	mov	word [nextMsg], ax
	cmp	ax, 160
	jl	L_lab8app_9
	; >>>>> Line:	78
	; >>>>> nextMsg = 0; 
	mov	word [nextMsg], 0
L_lab8app_9:
L_lab8app_8:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_4:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_5
	ALIGN	2
setOrientation:
	; >>>>> Line:	82
	; >>>>> void setOrientation(int Orientation){ 
	jmp	L_lab8app_11
L_lab8app_12:
	; >>>>> Line:	85
	; >>>>> switch(di 
	mov	ax, word [NewPieceOrientation]
	sub	ax, word [bp+4]
	mov	word [bp-2], ax
	; >>>>> Line:	85
	; >>>>> switch(di 
	mov	ax, word [bp-2]
	sub	ax, -3
	je	L_lab8app_15
	dec	ax
	je	L_lab8app_16
	dec	ax
	je	L_lab8app_17
	dec	ax
	je	L_lab8app_18
	dec	ax
	je	L_lab8app_19
	dec	ax
	je	L_lab8app_20
	dec	ax
	je	L_lab8app_21
	jmp	L_lab8app_14
L_lab8app_15:
	; >>>>> Line:	87
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	88
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_16:
	; >>>>> Line:	90
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	91
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	92
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_17:
	; >>>>> Line:	94
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	95
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_18:
	; >>>>> Line:	97
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_19:
	; >>>>> Line:	99
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	100
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_20:
	; >>>>> Line:	102
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	103
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
	; >>>>> Line:	104
	; >>>>> break; 
	jmp	L_lab8app_13
L_lab8app_21:
	; >>>>> Line:	106
	; >>>>> addToQueue(NewPieceID, 1, 0); 
	xor	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_14:
L_lab8app_13:
	; >>>>> Line:	107
	; >>>>> break; 
L_lab8app_22:
	; >>>>> Line:	112
	; >>>>> return ; 
	mov	sp, bp
	pop	bp
	ret
L_lab8app_11:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_lab8app_12
	ALIGN	2
setColumn:
	; >>>>> Line:	115
	; >>>>> void setColumn(int Column){ 
	jmp	L_lab8app_24
L_lab8app_25:
	; >>>>> Line:	118
	; >>>>> if(NewPieceColumn > Column){ 
	mov	word [bp-2], 0
	; >>>>> Line:	118
	; >>>>> if(NewPieceColumn > Column){ 
	mov	ax, word [NewPieceColumn]
	cmp	ax, word [bp+4]
	jbe	L_lab8app_26
	; >>>>> Line:	119
	; >>>>> dif = NewPieceColumn - Column; 
	mov	ax, word [NewPieceColumn]
	sub	ax, word [bp+4]
	mov	word [bp-4], ax
	; >>>>> Line:	120
	; >>>>> for(i=0;i<dif;i++){ 
	mov	word [bp-2], 0
	jmp	L_lab8app_28
L_lab8app_27:
	; >>>>> Line:	121
	; >>>>> addToQueue(NewPieceID, 0, 0); 
	xor	ax, ax
	push	ax
	xor	ax, ax
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_30:
	inc	word [bp-2]
L_lab8app_28:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-2]
	jg	L_lab8app_27
L_lab8app_29:
	jmp	L_lab8app_31
L_lab8app_26:
	; >>>>> Line:	123
	; >>>>> }else if(NewPieceColumn < Column){ 
	mov	ax, word [NewPieceColumn]
	cmp	ax, word [bp+4]
	jae	L_lab8app_32
	; >>>>> Line:	124
	; >>>>> dif = Column - NewPieceColumn; 
	mov	ax, word [bp+4]
	sub	ax, word [NewPieceColumn]
	mov	word [bp-4], ax
	; >>>>> Line:	125
	; >>>>> for(i=0;i<dif;i++){ 
	mov	word [bp-2], 0
	jmp	L_lab8app_34
L_lab8app_33:
	; >>>>> Line:	126
	; >>>>> addToQueue(NewPieceID, 0, 1); 
	mov	ax, 1
	push	ax
	xor	ax, ax
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_36:
	inc	word [bp-2]
L_lab8app_34:
	mov	ax, word [bp-4]
	cmp	ax, word [bp-2]
	jg	L_lab8app_33
L_lab8app_35:
L_lab8app_32:
L_lab8app_31:
L_lab8app_37:
	; >>>>> Line:	131
	; >>>>> return ; 
	mov	sp, bp
	pop	bp
	ret
L_lab8app_24:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_lab8app_25
L_lab8app_40:
	DB	" D: ",0
L_lab8app_39:
	DB	"C: ",0
	ALIGN	2
SimpCommTask:
	; >>>>> Line:	135
	; >>>>> { 
	jmp	L_lab8app_41
L_lab8app_42:
	; >>>>> Line:	137
	; >>>>> while (1) 
	jmp	L_lab8app_44
L_lab8app_43:
	; >>>>> Line:	139
	; >>>>> YKSemPend(RCSemPtr); 
	push	word [RCSemPtr]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	140
	; >>>>> tmp = (struct msg *) YKQPend(MsgQPtr); 
	push	word [MsgQPtr]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	141
	; >>>>> if(0==1){ 
	jmp	L_lab8app_46
	; >>>>> Line:	142
	; >>>>> printString("C: "); 
	mov	ax, L_lab8app_39
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	143
	; >>>>>  
	mov	si, word [bp-2]
	add	si, 2
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	144
	; >>>>> printString(" D: "); 
	mov	ax, L_lab8app_40
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	145
	; >>>>> printInt(tmp->direction); 
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	146
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab8app_46:
	; >>>>> Line:	148
	; >>>>> if(tmp->cmd == 0){ 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [si]
	test	ax, ax
	jne	L_lab8app_47
	; >>>>> Line:	149
	; >>>>> SlidePiece(tmp->pieceID, tmp->direction); 
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	mov	si, word [bp-2]
	push	word [si]
	call	SlidePiece
	add	sp, 4
	jmp	L_lab8app_48
L_lab8app_47:
	; >>>>> Line:	151
	; >>>>> RotatePiece(tmp->pieceID, tmp->direction); 
	mov	si, word [bp-2]
	add	si, 4
	push	word [si]
	mov	si, word [bp-2]
	push	word [si]
	call	RotatePiece
	add	sp, 4
L_lab8app_48:
L_lab8app_44:
	jmp	L_lab8app_43
L_lab8app_45:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_41:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_lab8app_42
L_lab8app_50:
	DB	"NP NPTSK ",0xD,0xA,0
	ALIGN	2
NewPieceTask:
	; >>>>> Line:	158
	; >>>>> { 
	jmp	L_lab8app_51
L_lab8app_52:
	; >>>>> Line:	160
	; >>>>> while(1){ 
	jmp	L_lab8app_54
L_lab8app_53:
	; >>>>> Line:	161
	; >>>>> bin0B = bin0A; 
	mov	al, byte [bin0A]
	mov	byte [bin0B], al
	; >>>>> Line:	162
	; >>>>> bin1B = bin1A; 
	mov	al, byte [bin1A]
	mov	byte [bin1B], al
	; >>>>> Line:	163
	; >>>>> bin0BL = bin0AL; 
	mov	al, byte [bin0AL]
	mov	byte [bin0BL], al
	; >>>>> Line:	164
	; >>>>> bin1BL = bin1AL; 
	mov	al, byte [bin1AL]
	mov	byte [bin1BL], al
	; >>>>> Line:	165
	; >>>>> if(0==1){ 
	jmp	L_lab8app_56
	; >>>>> Line:	166
	; >>>>> printInt(bin0B); 
	mov	al, byte [bin0B]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	167
	; >>>>> printInt(bin1B); 
	mov	al, byte [bin1B]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	168
	; >>>>> printInt(bin0BL); 
	mov	al, byte [bin0BL]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	169
	; >>>>> printInt(bin1BL); 
	mov	al, byte [bin1BL]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	170
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab8app_56:
	; >>>>> Line:	173
	; >>>>> e{ 
	push	word [NPSemPtr]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	174
	; >>>>> if(0==1){ 
	jmp	L_lab8app_57
	; >>>>> Line:	175
	; >>>>> printString("NP NPTSK \r\n"); 
	mov	ax, L_lab8app_50
	push	ax
	call	printString
	add	sp, 2
L_lab8app_57:
	; >>>>> Line:	180
	; >>>>> if(NewPieceColumn==0){ 
	mov	ax, word [NewPieceColumn]
	test	ax, ax
	jne	L_lab8app_58
	; >>>>> Line:	181
	; >>>>> setColumn(1); 
	mov	ax, 1
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	182
	; >>>>> NewPieceColumn = 1; 
	mov	word [NewPieceColumn], 1
	jmp	L_lab8app_59
L_lab8app_58:
	; >>>>> Line:	183
	; >>>>> }else if(NewPieceColumn==5){ 
	cmp	word [NewPieceColumn], 5
	jne	L_lab8app_60
	; >>>>> Line:	184
	; >>>>> setColumn(4); 
	mov	ax, 4
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	185
	; >>>>> NewPieceColumn = 4; 
	mov	word [NewPieceColumn], 4
L_lab8app_60:
L_lab8app_59:
	; >>>>> Line:	188
	; >>>>> if(NewPieceType==1){ 
	cmp	word [NewPieceType], 1
	jne	L_lab8app_61
	; >>>>> Line:	190
	; >>>>> if(NewPieceOrientation==1){ 
	cmp	word [NewPieceOrientation], 1
	jne	L_lab8app_62
	; >>>>> Line:	191
	; >>>>> addToQueue(NewPieceID, 1, 1); 
	mov	ax, 1
	push	ax
	mov	ax, 1
	push	ax
	push	word [NewPieceID]
	call	addToQueue
	add	sp, 6
L_lab8app_62:
	; >>>>> Line:	193
	; >>>>> if(bin0B==0){ 
	mov	al, byte [bin0B]
	test	al, al
	jne	L_lab8app_63
	; >>>>> Line:	194
	; >>>>> if(bin1B==0){ 
	mov	al, byte [bin1B]
	test	al, al
	jne	L_lab8app_64
	; >>>>> Line:	195
	; >>>>> if(bin0BL < bin1BL){ 
	mov	al, byte [bin1BL]
	cmp	al, byte [bin0BL]
	jle	L_lab8app_65
	; >>>>> Line:	196
	; >>>>> setColumn(1); 
	mov	ax, 1
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	197
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	198
	; >>>>> bin0A = 0; 
	mov	byte [bin0A], 0
	jmp	L_lab8app_66
L_lab8app_65:
	; >>>>> Line:	200
	; >>>>> mn(5); 
	mov	ax, 4
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	201
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	202
	; >>>>> bin1A = 0; 
	mov	byte [bin1A], 0
L_lab8app_66:
	jmp	L_lab8app_67
L_lab8app_64:
	; >>>>> Line:	206
	; >>>>> setColumn(1); 
	mov	ax, 1
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	207
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	208
	; >>>>> bin0A = 0; 
	mov	byte [bin0A], 0
L_lab8app_67:
	jmp	L_lab8app_68
L_lab8app_63:
	; >>>>> Line:	211
	; >>>>> setColumn(4); 
	mov	ax, 4
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	212
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	213
	; >>>>> bin1A = 0; 
	mov	byte [bin1A], 0
L_lab8app_68:
	jmp	L_lab8app_69
L_lab8app_61:
	; >>>>> Line:	218
	; >>>>> if((bin0B==0)){ 
	mov	al, byte [bin0B]
	test	al, al
	jne	L_lab8app_70
	; >>>>> Line:	219
	; >>>>> if(bin1B==0){ 
	mov	al, byte [bin1B]
	test	al, al
	jne	L_lab8app_71
	; >>>>> Line:	220
	; >>>>> if(bin0BL < bin1BL){ 
	mov	al, byte [bin1BL]
	cmp	al, byte [bin0BL]
	jle	L_lab8app_72
	; >>>>> Line:	221
	; >>>>> setOrientation(0); 
	xor	ax, ax
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	222
	; >>>>> setColumn(0); 
	xor	ax, ax
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	223
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	224
	; >>>>> bin0A = 1; 
	mov	byte [bin0A], 1
	jmp	L_lab8app_73
L_lab8app_72:
	; >>>>> Line:	226
	; >>>>> setOrientation(1); 
	mov	ax, 1
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	227
	; >>>>> setColumn(5); 
	mov	ax, 5
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	228
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	229
	; >>>>> bin1A = 1; 
	mov	byte [bin1A], 1
L_lab8app_73:
	jmp	L_lab8app_74
L_lab8app_71:
	; >>>>> Line:	232
	; >>>>> setOrientation(3); 
	mov	ax, 3
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	233
	; >>>>> setColumn(3); 
	mov	ax, 3
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	234
	; >>>>> bin1AL++; 
	inc	byte [bin1AL]
	; >>>>> Line:	235
	; >>>>> bin1A = 0; 
	mov	byte [bin1A], 0
L_lab8app_74:
	jmp	L_lab8app_75
L_lab8app_70:
	; >>>>> Line:	238
	; >>>>> setOrientation(2); 
	mov	ax, 2
	push	ax
	call	setOrientation
	add	sp, 2
	; >>>>> Line:	239
	; >>>>> setColumn(2); 
	mov	ax, 2
	push	ax
	call	setColumn
	add	sp, 2
	; >>>>> Line:	240
	; >>>>> bin0AL++; 
	inc	byte [bin0AL]
	; >>>>> Line:	241
	; >>>>> bin0A = 0; 
	mov	byte [bin0A], 0
L_lab8app_75:
L_lab8app_69:
L_lab8app_54:
	jmp	L_lab8app_53
L_lab8app_55:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_51:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_52
L_lab8app_79:
	DB	"%>",0xD,0xA,0
L_lab8app_78:
	DB	", CPU: ",0
L_lab8app_77:
	DB	"<CS: ",0
	ALIGN	2
StatsTask:
	; >>>>> Line:	248
	; >>>>> { 
	jmp	L_lab8app_80
L_lab8app_81:
	; >>>>> Line:	252
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	253
	; >>>>> YKDelayTask(5); 
	mov	ax, 5
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	254
	; >>>>> max = YKIdleCount / 25; 
	mov	ax, word [YKIdleCount]
	cwd
	mov	cx, 25
	idiv	cx
	mov	word [bp-2], ax
	; >>>>> Line:	256
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	258
	; >>>>> YKNewTask(SimpCommTask, (void *) &SimpCo 
	mov	al, 5
	push	ax
	mov	ax, (SimpCommTaskStk+1024)
	push	ax
	mov	ax, SimpCommTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	259
	; >>>>> YKNewTask(NewPieceTask, (void *) &NewPieceTaskStk[512], 10); 
	mov	al, 10
	push	ax
	mov	ax, (NewPieceTaskStk+1024)
	push	ax
	mov	ax, NewPieceTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	260
	; >>>>> StartSimptris(); 
	call	StartSimptris
	; >>>>> Line:	262
	; >>>>> while (1) 
	jmp	L_lab8app_83
L_lab8app_82:
	; >>>>> Line:	264
	; >>>>> YKDelayTask(20); 
	mov	ax, 20
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	266
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	267
	; >>>>> switchCount = YKCtxSwCount; 
	mov	ax, word [YKCtxSwCount]
	mov	word [bp-4], ax
	; >>>>> Line:	268
	; >>>>> idleCount = YKIdleCount; 
	mov	ax, word [YKIdleCount]
	mov	word [bp-6], ax
	; >>>>> Line:	269
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	271
	; >>>>> printString("<CS: "); 
	mov	ax, L_lab8app_77
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	272
	; >>>>> printInt((int)switchCount); 
	push	word [bp-4]
	call	printInt
	add	sp, 2
	; >>>>> Line:	273
	; >>>>> printString(", CPU: "); 
	mov	ax, L_lab8app_78
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	274
	; >>>>> tmp = (int) (idleCount/max); 
	mov	ax, word [bp-6]
	xor	dx, dx
	div	word [bp-2]
	mov	word [bp-8], ax
	; >>>>> Line:	275
	; >>>>> printInt(100-tmp); 
	mov	ax, 100
	sub	ax, word [bp-8]
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	276
	; >>>>> printString("%>\r\n"); 
	mov	ax, L_lab8app_79
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	278
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	279
	; >>>>> YKCtxSwCount = 0 
	mov	word [YKCtxSwCount], 0
	; >>>>> Line:	280
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	281
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_lab8app_83:
	jmp	L_lab8app_82
L_lab8app_84:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_80:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_lab8app_81
	ALIGN	2
main:
	; >>>>> Line:	287
	; >>>>> { 
	jmp	L_lab8app_86
L_lab8app_87:
	; >>>>> Line:	288
	; >>>>> YKInitialize(); 
	call	YKInitialize
	; >>>>> Line:	290
	; >>>>> MsgQPtr = YKQCreate(MsgQ, 80); 
	mov	ax, 80
	push	ax
	mov	ax, MsgQ
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [MsgQPtr], ax
	; >>>>> Line:	292
	; >>>>> YKNewTask(StatsTask, (void *) &StatsTaskStk[512], 50); 
	mov	al, 50
	push	ax
	mov	ax, (StatsTaskStk+1024)
	push	ax
	mov	ax, StatsTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	294
	; >>>>> SeedSimptris(0xDEADBEEF); 
	mov	ax, 48879
	mov	dx, 57005
	push	dx
	push	ax
	call	SeedSimptris
	add	sp, 4
	; >>>>> Line:	296
	; >>>>> NPSemPtr = YKSemCreate(0); 
	xor	ax, ax
	push	ax
	call	YKSemCreate
	add	sp, 2
	mov	word [NPSemPtr], ax
	; >>>>> Line:	297
	; >>>>> RCSemPtr = YKSemCreate(1); 
	mov	ax, 1
	push	ax
	call	YKSemCreate
	add	sp, 2
	mov	word [RCSemPtr], ax
	; >>>>> Line:	300
	; >>>>> YKRun(); 
	call	YKRun
	mov	sp, bp
	pop	bp
	ret
L_lab8app_86:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_87
	ALIGN	2
MsgArray:
	TIMES	960 db 0
SimpCommTaskStk:
	TIMES	1024 db 0
NewPieceTaskStk:
	TIMES	1024 db 0
StatsTaskStk:
	TIMES	1024 db 0
MsgQ:
	TIMES	160 db 0
MsgQPtr:
	TIMES	2 db 0
RCSemPtr:
	TIMES	2 db 0
NPSemPtr:
	TIMES	2 db 0
resetISR:
	push 	bp
	mov 	bp, sp
	call resetISRC

tickISR:
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	bp
	push	es
	push	ds

	call 	YKEnterISR		;call before enabling interrupts again
	sti
	call	tickISRC
	cli						; Note: due to notes in midterm review, EOI call and cli order have been swapped.
							; it previously was call signalEOI THEN cli
	call	signalEOI
	call 	YKExitISR

	pop		ds
	pop		es
	pop		bp
	pop		di
	pop		si
	pop		dx
	pop		cx
	pop		bx
	pop		ax
	iret
	

kbISR:
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	bp
	push	es
	push	ds

	call 	YKEnterISR
	sti
	call	kbISRC
	cli
	call	signalEOI
	call	YKExitISR

	pop		ds
	pop		es
	pop		bp
	pop		di
	pop		si
	pop		dx
	pop		cx
	pop		bx
	pop		ax
	iret
	align	2
SlidePiece:	; void SlidePiece(int ID, int direction)
	push	bp
	mov	bp, sp
	push	ax
	push	dx
 	mov	ah, 0		; Slide piece operation
  	mov	al, [bp+6]	; Move direction (loword only)
	mov	dx, [bp+4]	; Move id
	int	1Bh		; Call Simptris services
	pop	dx
	pop	ax
	pop	bp
	ret
RotatePiece:	; void RotatePiece(int ID, int direction)
	push	bp
	mov	bp, sp
	push	ax
	push	dx
 	mov	ah, 1		; Rotate piece operation
 	mov	al, [bp+6]	; Move direction (loword only)
	mov	dx, [bp+4]	; Move id
	int	1Bh		; Call Simptris services
	pop	dx
	pop	ax
	pop	bp
	ret
SeedSimptris:	; void SeedSimptris(long seed)
	push	bp
	mov	bp, sp
	push	ax
	push	cx
	push    dx
 	mov	ah, 2		; Seed operation
	mov	dx, [bp+4]	; Move loword of seed
	mov	cx, [bp+6]	; Move hiword of seed
	int	1Bh		; Call Simptris services
	pop	dx
	pop	cx
	pop	ax
	pop	bp
	ret
StartSimptris:	; void StartSimptris(void)
	push	ax
 	mov	ah, 3		; Start Simptris operation
	int	1Bh		; Call Simptris services
	pop	ax
	ret

; Generated by c86 (BYU-NASM) 5.1 (beta) from simptris_inth.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
gameOverISRC:
	; >>>>> Line:	14
	; >>>>> void gameOverISRC(void) { 
	jmp	L_simptris_inth_1
L_simptris_inth_2:
	; >>>>> Line:	15
	; >>>>> exit(0); 
	xor	al, al
	push	ax
	call	exit
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_simptris_inth_1:
	push	bp
	mov	bp, sp
	jmp	L_simptris_inth_2
	ALIGN	2
newPieceISRC:
	; >>>>> Line:	18
	; >>>>> void newPieceISRC(void) { 
	jmp	L_simptris_inth_4
L_simptris_inth_5:
	; >>>>> Line:	20
	; >>>>> YKSemPost(NPSemPtr); 
	push	word [NPSemPtr]
	call	YKSemPost
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_simptris_inth_4:
	push	bp
	mov	bp, sp
	jmp	L_simptris_inth_5
	ALIGN	2
receivedCommandISRC:
	; >>>>> Line:	23
	; >>>>> void receivedCommandISRC(void) { 
	jmp	L_simptris_inth_7
L_simptris_inth_8:
	; >>>>> Line:	24
	; >>>>> YKSemPost(RCSemPtr); 
	push	word [RCSemPtr]
	call	YKSemPost
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_simptris_inth_7:
	push	bp
	mov	bp, sp
	jmp	L_simptris_inth_8
	ALIGN	2
touchdownISRC:
	; >>>>> Line:	27
	; >>>>> voi 
	jmp	L_simptris_inth_10
L_simptris_inth_11:
	; >>>>> Line:	29
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_simptris_inth_10:
	push	bp
	mov	bp, sp
	jmp	L_simptris_inth_11
	ALIGN	2
lineclearISRC:
	; >>>>> Line:	31
	; >>>>> void lineclearISRC(void) { 
	jmp	L_simptris_inth_13
L_simptris_inth_14:
	; >>>>> Line:	32
	; >>>>> bin0AL--; 
	dec	byte [bin0AL]
	; >>>>> Line:	33
	; >>>>> bin1AL--; 
	dec	byte [bin1AL]
	mov	sp, bp
	pop	bp
	ret
L_simptris_inth_13:
	push	bp
	mov	bp, sp
	jmp	L_simptris_inth_14
gameOverISR:
    push 	bp
    mov 	bp, sp
    call gameOverISRC

newPieceISR:
    push	ax
    push	bx
    push	cx
    push	dx
    push	si
    push	di
    push	bp
    push	es
    push	ds

    call 	YKEnterISR		;call before enabling interrupts again
    sti
    call	newPieceISRC
    cli
    call	signalEOI
    call 	YKExitISR

    pop		ds
    pop		es
    pop		bp
    pop		di
    pop		si
    pop		dx
    pop		cx
    pop		bx
    pop		ax
    iret

receivedCommandISR:
    push	ax
    push	bx
    push	cx
    push	dx
    push	si
    push	di
    push	bp
    push	es
    push	ds

    call 	YKEnterISR		;call before enabling interrupts again
    sti
    call	receivedCommandISRC
    cli
    call	signalEOI
    call 	YKExitISR

    pop		ds
    pop		es
    pop		bp
    pop		di
    pop		si
    pop		dx
    pop		cx
    pop		bx
    pop		ax
    iret

touchdownISR:
    push	ax
    push	bx
    push	cx
    push	dx
    push	si
    push	di
    push	bp
    push	es
    push	ds

    call 	YKEnterISR		;call before enabling interrupts again
    sti
    call	touchdownISRC
    cli
    call	signalEOI
    call 	YKExitISR

    pop		ds
    pop		es
    pop		bp
    pop		di
    pop		si
    pop		dx
    pop		cx
    pop		bx
    pop		ax
    iret

lineclearISR:
    push	ax
    push	bx
    push	cx
    push	dx
    push	si
    push	di
    push	bp
    push	es
    push	ds

    call 	YKEnterISR		;call before enabling interrupts again
    sti
    call	lineclearISRC
    cli
    call	signalEOI
    call 	YKExitISR

    pop		ds
    pop		es
    pop		bp
    pop		di
    pop		si
    pop		dx
    pop		cx
    pop		bx
    pop		ax
    iret
; Generated by c86 (BYU-NASM) 5.1 (beta) from myinth.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
resetISRC:
	; >>>>> Line:	9
	; >>>>> void resetISRC(void) { 
	jmp	L_myinth_1
L_myinth_2:
	; >>>>> Line:	10
	; >>>>> exit(0); 
	xor	al, al
	push	ax
	call	exit
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_myinth_1:
	push	bp
	mov	bp, sp
	jmp	L_myinth_2
	ALIGN	2
tickISRC:
	; >>>>> Line:	13
	; >>>>> void tickISRC(void) { 
	jmp	L_myinth_4
L_myinth_5:
	; >>>>> Line:	14
	; >>>>> YKTickHandler(); 
	call	YKTickHandler
	mov	sp, bp
	pop	bp
	ret
L_myinth_4:
	push	bp
	mov	bp, sp
	jmp	L_myinth_5
	ALIGN	2
kbISRC:
	; >>>>> Line:	17
	; >>>>> void kbISRC(void) { 
	jmp	L_myinth_7
L_myinth_8:
	; >>>>> Line:	19
	; >>>>> c = KeyBuffer; 
	mov	al, byte [KeyBuffer]
	mov	byte [bp-1], al
	mov	sp, bp
	pop	bp
	ret
L_myinth_7:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_myinth_8
; Generated by c86 (BYU-NASM) 5.1 (beta) from yakc.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
currentTask:
	DW	0
taskSaveCTX:
	DW	0
TCBIdx:
	DW	0
SEMIdx:
	DW	0
YKQIdx:
	DW	0
YKEIdx:
	DW	0
YKISRDepth:
	DW	0
YKCtxSwCount:
	DW	0
YKIdleCount:
	DW	0
YKTickNum:
	DW	0
YKKernalStarted:
	DB	0
	ALIGN	2
printDebug:
	; >>>>> Line:	72
	; >>>>> void printDebug(char *string) { 
	jmp	L_yakc_1
L_yakc_2:
	; >>>>> Line:	73
	; >>>>> if(0 == 1){ 
	jmp	L_yakc_3
	; >>>>> Line:	74
	; >>>>> printString(string); 
	push	word [bp+4]
	call	printString
	add	sp, 2
	; >>>>> Line:	75
	; >>>>> printNewLine(); 
	call	printNewLine
L_yakc_3:
	mov	sp, bp
	pop	bp
	ret
L_yakc_1:
	push	bp
	mov	bp, sp
	jmp	L_yakc_2
L_yakc_5:
	DB	"IN YKINITIALIZE - CHECK",0
	ALIGN	2
YKInitialize:
	; >>>>> Line:	79
	; >>>>> = 0; 
	jmp	L_yakc_6
L_yakc_7:
	; >>>>> Line:	81
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	82
	; >>>>> printDebug("IN YKINITIALIZE - CHECK"); 
	mov	ax, L_yakc_5
	push	ax
	call	printDebug
	add	sp, 2
	; >>>>> Line:	83
	; >>>>> YKNewTask(YKIdleTask, (void *)&YKIdleStk[256], 100); 
	mov	al, 100
	push	ax
	mov	ax, (YKIdleStk+512)
	push	ax
	mov	ax, YKIdleTask
	push	ax
	call	YKNewTask
	add	sp, 6
	mov	sp, bp
	pop	bp
	ret
L_yakc_6:
	push	bp
	mov	bp, sp
	jmp	L_yakc_7
	ALIGN	2
YKIdleTask:
	; >>>>> Line:	89
	; >>>>> void YKIdleTask(void){ 
	jmp	L_yakc_9
L_yakc_10:
	; >>>>> Line:	90
	; >>>>> while(1){ 
	jmp	L_yakc_12
L_yakc_11:
	; >>>>> Line:	92
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	93
	; >>>>> YKIdleCount++; 
	inc	word [YKIdleCount]
	; >>>>> Line:	94
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_12:
	jmp	L_yakc_11
L_yakc_13:
	mov	sp, bp
	pop	bp
	ret
L_yakc_9:
	push	bp
	mov	bp, sp
	jmp	L_yakc_10
	ALIGN	2
YKNewTask:
	; >>>>> Line:	98
	; >>>>> void YKNewTask(void (* task)(void), void *taskStack, unsigned char priority){ 
	jmp	L_yakc_15
L_yakc_16:
	; >>>>> Line:	101
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	102
	; >>>>> TCBArray[TCBIdx].state = 1; 
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	add	ax, TCBArray
	mov	si, ax
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	103
	; >>>>> TCBArray[TCBIdx].priority = priority; 
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	add	ax, TCBArray
	mov	si, ax
	add	si, 3
	mov	al, byte [bp+8]
	mov	byte [si], al
	; >>>>> Line:	105
	; >>>>> TCBArray[TCBIdx].delayCount = 0; 
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	add	ax, TCBArray
	mov	si, ax
	add	si, 16
	mov	word [si], 0
	; >>>>> Line:	107
	; >>>>> newSP = (unsigned *) taskStack - 11; 
	mov	ax, word [bp+6]
	sub	ax, 22
	mov	word [bp-2], ax
	; >>>>> Line:	122
	; >>>>> newSP[0] = 0; 
	mov	si, word [bp-2]
	mov	word [si], 0
	; >>>>> Line:	123
	; >>>>> newSP[1] = 
	mov	si, word [bp-2]
	add	si, 2
	mov	word [si], 0
	; >>>>> Line:	124
	; >>>>> newSP[2] = 0; 
	mov	si, word [bp-2]
	add	si, 4
	mov	word [si], 0
	; >>>>> Line:	125
	; >>>>> newSP[3] = 0; 
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], 0
	; >>>>> Line:	126
	; >>>>> newSP[4] = 0; 
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], 0
	; >>>>> Line:	127
	; >>>>> newSP[5] = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	128
	; >>>>> newSP[6] = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	129
	; >>>>> newSP[7] = 0; 
	mov	si, word [bp-2]
	add	si, 14
	mov	word [si], 0
	; >>>>> Line:	130
	; >>>>> newSP[7] = 0; 
	mov	si, word [bp-2]
	add	si, 14
	mov	word [si], 0
	; >>>>> Line:	131
	; >>>>> newSP[8] = (unsigned) task; 
	mov	si, word [bp-2]
	add	si, 16
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	132
	; >>>>> newSP[9] = 0; 
	mov	si, word [bp-2]
	add	si, 18
	mov	word [si], 0
	; >>>>> Line:	133
	; >>>>> newSP[10] = 0x0200; 
	mov	si, word [bp-2]
	add	si, 20
	mov	word [si], 512
	; >>>>> Line:	135
	; >>>>> TCBArray[TCBIdx].sp = newSP-1; 
	mov	ax, word [bp-2]
	sub	ax, 2
	push	ax
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	mov	dx, ax
	mov	si, dx
	add	si, TCBArray
	pop	ax
	mov	word [si], ax
	; >>>>> Line:	138
	; >>>>> if(TCBIdx == 0){ 
	mov	ax, word [TCBIdx]
	test	ax, ax
	jne	L_yakc_17
	; >>>>> Line:	139
	; >>>>> taskhead = &TCBArray[TCBIdx]; 
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	add	ax, TCBArray
	mov	word [taskhead], ax
	; >>>>> Line:	140
	; >>>>> TCBArray[TCBIdx].nextTask = 0; 
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	add	ax, TCBArray
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	jmp	L_yakc_18
L_yakc_17:
	; >>>>> Line:	144
	; >>>>> if(priority < taskhead->priority){ 
	mov	si, word [taskhead]
	add	si, 3
	mov	al, byte [bp+8]
	cmp	al, byte [si]
	jae	L_yakc_19
	; >>>>> Line:	146
	; >>>>> TCBArray[TCBIdx].nextTask = taskhead; 
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	add	ax, TCBArray
	mov	si, ax
	add	si, 4
	mov	ax, word [taskhead]
	mov	word [si], ax
	; >>>>> Line:	147
	; >>>>> taskhead = &TCBArray[TCBIdx]; 
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	add	ax, TCBArray
	mov	word [taskhead], ax
	jmp	L_yakc_20
L_yakc_19:
	; >>>>> Line:	151
	; >>>>> traveser = taskhead; 
	mov	ax, word [taskhead]
	mov	word [bp-4], ax
	; >>>>> Line:	153
	; >>>>> while(traveser){ 
	jmp	L_yakc_22
L_yakc_21:
	; >>>>> Line:	154
	; >>>>> if(priorit 
	mov	si, word [bp-4]
	add	si, 4
	mov	si, word [si]
	add	si, 3
	mov	al, byte [bp+8]
	cmp	al, byte [si]
	jae	L_yakc_24
	; >>>>> Line:	155
	; >>>>> TCBArray[TCBIdx].nextTask = traveser->nextTask; 
	mov	si, word [bp-4]
	add	si, 4
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	add	ax, TCBArray
	mov	di, ax
	add	di, 4
	mov	ax, word [si]
	mov	word [di], ax
	; >>>>> Line:	156
	; >>>>> traveser->nextTask = &TCBArray[TCBIdx]; 
	mov	ax, word [TCBIdx]
	mov	cx, 18
	imul	cx
	add	ax, TCBArray
	mov	si, word [bp-4]
	add	si, 4
	mov	word [si], ax
	; >>>>> Line:	157
	; >>>>> break; 
	jmp	L_yakc_23
L_yakc_24:
	; >>>>> Line:	159
	; >>>>> traveser = traveser->nextTask; 
	mov	si, word [bp-4]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-4], ax
L_yakc_22:
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_yakc_21
L_yakc_23:
L_yakc_20:
L_yakc_18:
	; >>>>> Line:	164
	; >>>>> TCBIdx++; 
	inc	word [TCBIdx]
	; >>>>> Line:	165
	; >>>>> if(0){ 
	jmp	L_yakc_25
	; >>>>> Line:	166
	; >>>>> dumpLists(); 
	call	dumpLists
L_yakc_25:
	; >>>>> Line:	169
	; >>>>> if(YKKernalStarted == 1){ 
	cmp	byte [YKKernalStarted], 1
	jne	L_yakc_26
	; >>>>> Line:	170
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_26:
	mov	sp, bp
	pop	bp
	ret
L_yakc_15:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_yakc_16
L_yakc_31:
	DB	"] ",0
L_yakc_30:
	DB	",",0
L_yakc_29:
	DB	"[",0
L_yakc_28:
	DB	"TCBList: ",0
	ALIGN	2
dumpLists:
	; >>>>> Line:	175
	; >>>>> void dumpLists(){ 
	jmp	L_yakc_32
L_yakc_33:
	; >>>>> Line:	177
	; >>>>> traveser = taskhead; 
	mov	ax, word [taskhead]
	mov	word [bp-2], ax
	; >>>>> Line:	178
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	179
	; >>>>> printString("TCBList: "); 
	mov	ax, L_yakc_28
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	180
	; >>>>> while(traveser){ 
	jmp	L_yakc_35
L_yakc_34:
	; >>>>> Line:	181
	; >>>>> printString("["); 
	mov	ax, L_yakc_29
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	182
	; >>>>> printInt(traveser->priority); 
	mov	si, word [bp-2]
	add	si, 3
	mov	al, byte [si]
	xor	ah, ah
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	183
	; >>>>> printString(","); 
	mov	ax, L_yakc_30
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	184
	; >>>>> printInt(traveser->state 
	mov	si, word [bp-2]
	add	si, 2
	mov	al, byte [si]
	xor	ah, ah
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	185
	; >>>>> printString(","); 
	mov	ax, L_yakc_30
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	186
	; >>>>> printInt(traveser->delayCount); 
	mov	si, word [bp-2]
	add	si, 16
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	187
	; >>>>> printString("] "); 
	mov	ax, L_yakc_31
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	189
	; >>>>> traveser = traveser->nextTask; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_35:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_34
L_yakc_36:
	; >>>>> Line:	192
	; >>>>> printNewLine(); 
	call	printNewLine
	mov	sp, bp
	pop	bp
	ret
L_yakc_32:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_33
L_yakc_39:
	DB	" | ",0
L_yakc_38:
	DB	"Sem Values: ",0
	ALIGN	2
dumpSems:
	; >>>>> Line:	195
	; >>>>> void dumpSems(){ 
	jmp	L_yakc_40
L_yakc_41:
	; >>>>> Line:	197
	; >>>>> printString("Sem Values: "); 
	mov	word [bp-2], 0
	; >>>>> Line:	197
	; >>>>> printString("Sem Values: "); 
	mov	ax, L_yakc_38
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	198
	; >>>>> for(i=0; i<SEMIdx; i++){ 
	mov	word [bp-2], 0
	jmp	L_yakc_43
L_yakc_42:
	; >>>>> Line:	199
	; >>>>> printInt(SEMArray[i]); 
	mov	ax, word [bp-2]
	shl	ax, 1
	mov	si, ax
	add	si, SEMArray
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	200
	; >>>>> printString(" | "); 
	mov	ax, L_yakc_39
	push	ax
	call	printString
	add	sp, 2
L_yakc_45:
	inc	word [bp-2]
L_yakc_43:
	mov	ax, word [SEMIdx]
	cmp	ax, word [bp-2]
	jg	L_yakc_42
L_yakc_44:
	; >>>>> Line:	203
	; >>>>> printNewLine(); 
	call	printNewLine
	mov	sp, bp
	pop	bp
	ret
L_yakc_40:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_41
L_yakc_47:
	DB	"IN YKRun",0
	ALIGN	2
YKRun:
	; >>>>> Line:	206
	; >>>>> void YKRun(void){ 
	jmp	L_yakc_48
L_yakc_49:
	; >>>>> Line:	207
	; >>>>> printDebug("IN YKRun"); 
	mov	ax, L_yakc_47
	push	ax
	call	printDebug
	add	sp, 2
	; >>>>> Line:	209
	; >>>>> YKKernalStarted = 1; 
	mov	byte [YKKernalStarted], 1
	; >>>>> Line:	211
	; >>>>> YKScheduler(0); 
	xor	al, al
	push	ax
	call	YKScheduler
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_yakc_48:
	push	bp
	mov	bp, sp
	jmp	L_yakc_49
L_yakc_53:
	DB	"Calling Dispatcher to dispatch task with priority ",0
L_yakc_52:
	DB	"SaveContext: ",0
L_yakc_51:
	DB	"IN YKScheduler",0
	ALIGN	2
YKScheduler:
	; >>>>> Line:	214
	; >>>>> void YKScheduler(char saveCTX){ 
	jmp	L_yakc_54
L_yakc_55:
	; >>>>> Line:	217
	; >>>>> traveser = taskhead; 
	mov	ax, word [taskhead]
	mov	word [bp-2], ax
	; >>>>> Line:	218
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	219
	; >>>>> printDebug("IN YKScheduler"); 
	mov	ax, L_yakc_51
	push	ax
	call	printDebug
	add	sp, 2
	; >>>>> Line:	220
	; >>>>> if(0){ 
	jmp	L_yakc_56
	; >>>>> Line:	221
	; >>>>> printString("SaveContext: "); 
	mov	ax, L_yakc_52
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	222
	; >>>>> printInt(saveCTX); 
	mov	al, byte [bp+4]
	cbw
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	223
	; >>>>> printNewLine(); 
	call	printNewLine
L_yakc_56:
	; >>>>> Line:	225
	; >>>>> while(traveser){ 
	jmp	L_yakc_58
L_yakc_57:
	; >>>>> Line:	226
	; >>>>> if(traveser->state == 1){ 
	mov	si, word [bp-2]
	add	si, 2
	cmp	byte [si], 1
	jne	L_yakc_60
	; >>>>> Line:	227
	; >>>>> nextTask = traveser; 
	mov	ax, word [bp-2]
	mov	word [nextTask], ax
	; >>>>> Line:	228
	; >>>>> break; 
	jmp	L_yakc_59
L_yakc_60:
	; >>>>> Line:	230
	; >>>>> traveser = traveser->nextTask; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_58:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_57
L_yakc_59:
	; >>>>> Line:	233
	; >>>>> if(nextTask != currentTask){ 
	mov	ax, word [currentTask]
	cmp	ax, word [nextTask]
	je	L_yakc_61
	; >>>>> Line:	234
	; >>>>> YKCtxSwCount++; 
	inc	word [YKCtxSwCount]
	; >>>>> Line:	235
	; >>>>> taskSaveCTX = currentTask; 
	mov	ax, word [currentTask]
	mov	word [taskSaveCTX], ax
	; >>>>> Line:	236
	; >>>>> currentTask = nextTask; 
	mov	ax, word [nextTask]
	mov	word [currentTask], ax
	; >>>>> Line:	237
	; >>>>> if(0){ 
	jmp	L_yakc_62
	; >>>>> Line:	238
	; >>>>> dumpLists(); 
	call	dumpLists
	; >>>>> Line:	239
	; >>>>> printString("Calling Dispatcher to dispatch task with priority "); 
	mov	ax, L_yakc_53
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	240
	; >>>>> printInt(nextTask->priority); 
	mov	si, word [nextTask]
	add	si, 3
	mov	al, byte [si]
	xor	ah, ah
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	241
	; >>>>> printNewLine(); 
	call	printNewLine
L_yakc_62:
	; >>>>> Line:	243
	; >>>>> YKDispatcher(saveCTX); 
	push	word [bp+4]
	call	YKDispatcher
	add	sp, 2
L_yakc_61:
	mov	sp, bp
	pop	bp
	ret
L_yakc_54:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_55
	ALIGN	2
YKDelayTask:
	; >>>>> Line:	248
	; >>>>> tate == 0){ 
	jmp	L_yakc_64
L_yakc_65:
	; >>>>> Line:	251
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	252
	; >>>>> if(newDelayCount == 0){ 
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_yakc_66
	; >>>>> Line:	253
	; >>>>> return ; 
	jmp	L_yakc_67
L_yakc_66:
	; >>>>> Line:	255
	; >>>>> currentTask->delayCount = newDelayCount; 
	mov	si, word [currentTask]
	add	si, 16
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	256
	; >>>>> currentTask->state = 0; 
	mov	si, word [currentTask]
	add	si, 2
	mov	byte [si], 0
	; >>>>> Line:	258
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	; >>>>> Line:	259
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_67:
	mov	sp, bp
	pop	bp
	ret
L_yakc_64:
	push	bp
	mov	bp, sp
	jmp	L_yakc_65
	ALIGN	2
YKEnterISR:
	; >>>>> Line:	263
	; >>>>> void YKEnterISR(void) { 
	jmp	L_yakc_69
L_yakc_70:
	; >>>>> Line:	265
	; >>>>> YKISRDepth++; 
	inc	word [YKISRDepth]
	mov	sp, bp
	pop	bp
	ret
L_yakc_69:
	push	bp
	mov	bp, sp
	jmp	L_yakc_70
	ALIGN	2
YKExitISR:
	; >>>>> Line:	268
	; >>>>> void YKExitISR(void) { 
	jmp	L_yakc_72
L_yakc_73:
	; >>>>> Line:	271
	; >>>>> YKISRDepth--; 
	dec	word [YKISRDepth]
	; >>>>> Line:	272
	; >>>>> if (YKISRDepth == 0) { 
	mov	ax, word [YKISRDepth]
	test	ax, ax
	jne	L_yakc_74
	; >>>>> Line:	273
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	; >>>>> Line:	274
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_74:
	mov	sp, bp
	pop	bp
	ret
L_yakc_72:
	push	bp
	mov	bp, sp
	jmp	L_yakc_73
L_yakc_78:
	DB	"SOMETHING HAS GONE HORRIBLY WRONG -- TASK HAS DELAY COUNT < 0. Priority: ",0
L_yakc_77:
	DB	"task now READY with priority ",0
L_yakc_76:
	DB	"IN YKTickHandler",0
	ALIGN	2
YKTickHandler:
	; >>>>> Line:	278
	; >>>>> void YKTickHandler(void) { 
	jmp	L_yakc_79
L_yakc_80:
	; >>>>> Line:	284
	; >>>>> traveser = taskhead; 
	mov	ax, word [taskhead]
	mov	word [bp-2], ax
	; >>>>> Line:	286
	; >>>>> YKTickNum++; 
	inc	word [YKTickNum]
	; >>>>> Line:	287
	; >>>>> printDebug("IN YKTickHandler"); 
	mov	ax, L_yakc_76
	push	ax
	call	printDebug
	add	sp, 2
	; >>>>> Line:	288
	; >>>>> while(traveser){ 
	jmp	L_yakc_82
L_yakc_81:
	; >>>>> Line:	289
	; >>>>> if(traveser->state == 0){ 
	mov	si, word [bp-2]
	add	si, 2
	mov	al, byte [si]
	test	al, al
	jne	L_yakc_84
	; >>>>> Line:	290
	; >>>>> traveser->de 
	mov	si, word [bp-2]
	add	si, 16
	dec	word [si]
	; >>>>> Line:	292
	; >>>>> if(traveser->delayCount == 0){ 
	mov	si, word [bp-2]
	add	si, 16
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_85
	; >>>>> Line:	294
	; >>>>> if(0 == 1){ 
	jmp	L_yakc_86
	; >>>>> Line:	295
	; >>>>> printString("task now READY with priority "); 
	mov	ax, L_yakc_77
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	296
	; >>>>> printInt(traveser->priority); 
	mov	si, word [bp-2]
	add	si, 3
	mov	al, byte [si]
	xor	ah, ah
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	297
	; >>>>> printNewLine(); 
	call	printNewLine
L_yakc_86:
	; >>>>> Line:	300
	; >>>>> traveser->state = 1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
L_yakc_85:
	; >>>>> Line:	303
	; >>>>> if(traveser->delayCount < 0){ 
	mov	si, word [bp-2]
	add	si, 16
	cmp	word [si], 0
	jge	L_yakc_87
	; >>>>> Line:	304
	; >>>>> printString("SOMETHING HAS GONE HORRIBLY WRONG -- TASK HAS DELAY COUNT < 0. Priority: "); 
	mov	ax, L_yakc_78
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	305
	; >>>>> printInt(traveser->priority); 
	mov	si, word [bp-2]
	add	si, 3
	mov	al, byte [si]
	xor	ah, ah
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	306
	; >>>>> printNewLine(); 
	call	printNewLine
L_yakc_87:
L_yakc_84:
	; >>>>> Line:	310
	; >>>>> traveser = traveser->nextTask; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_82:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_81
L_yakc_83:
	mov	sp, bp
	pop	bp
	ret
L_yakc_79:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_80
L_yakc_89:
	DB	"PROBLEM: Semaphore initialized with negative value!",0
	ALIGN	2
YKSemCreate:
	; >>>>> Line:	316
	; >>>>> YKSEM* YKSemCreate(int initialValue){ 
	jmp	L_yakc_90
L_yakc_91:
	; >>>>> Line:	319
	; >>>>> if(initialValue < 
	cmp	word [bp+4], 0
	jge	L_yakc_92
	; >>>>> Line:	321
	; >>>>> if(0 == 1){ 
	jmp	L_yakc_93
	; >>>>> Line:	322
	; >>>>> printString("PROBLEM: Semaphore initialized with negative value!"); 
	mov	ax, L_yakc_89
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	323
	; >>>>> printNewLine(); 
	call	printNewLine
L_yakc_93:
	; >>>>> Line:	325
	; >>>>> return 0; 
	xor	ax, ax
	jmp	L_yakc_94
L_yakc_92:
	; >>>>> Line:	328
	; >>>>> temp = &SEMArray[SEMIdx]; 
	mov	ax, word [SEMIdx]
	shl	ax, 1
	add	ax, SEMArray
	mov	word [bp-2], ax
	; >>>>> Line:	329
	; >>>>> *temp = initialValue; 
	mov	si, word [bp-2]
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	330
	; >>>>> SEMIdx++; 
	inc	word [SEMIdx]
	; >>>>> Line:	331
	; >>>>> return temp; 
	mov	ax, word [bp-2]
L_yakc_94:
	mov	sp, bp
	pop	bp
	ret
L_yakc_90:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_91
	ALIGN	2
YKSemPend:
	; >>>>> Line:	335
	; >>>>> void YKSemPend(YKSEM *semaphore){ 
	jmp	L_yakc_96
L_yakc_97:
	; >>>>> Line:	336
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	337
	; >>>>> if(*semaphore == 0){ 
	mov	si, word [bp+4]
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_98
	; >>>>> Line:	338
	; >>>>> currentTask->state = 3; 
	mov	si, word [currentTask]
	add	si, 2
	mov	byte [si], 3
	; >>>>> Line:	339
	; >>>>> currentTask->blocker = semaphore; 
	mov	si, word [currentTask]
	add	si, 6
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	340
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_98:
	; >>>>> Line:	342
	; >>>>> (*semaphore)--; 
	mov	si, word [bp+4]
	dec	word [si]
	; >>>>> Line:	343
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_96:
	push	bp
	mov	bp, sp
	jmp	L_yakc_97
	ALIGN	2
YKSemPost:
	; >>>>> Line:	347
	; >>>>> void YKSemPost(YKSEM *semaphore){ 
	jmp	L_yakc_100
L_yakc_101:
	; >>>>> Line:	352
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	353
	; >>>>> (*semaphore)++; 
	mov	si, word [bp+4]
	inc	word [si]
	; >>>>> Line:	354
	; >>>>> traveser = task 
	mov	ax, word [taskhead]
	mov	word [bp-2], ax
	; >>>>> Line:	356
	; >>>>> while(traveser){ 
	jmp	L_yakc_103
L_yakc_102:
	; >>>>> Line:	357
	; >>>>> if(traveser->state == 3){ 
	mov	si, word [bp-2]
	add	si, 2
	cmp	byte [si], 3
	jne	L_yakc_105
	; >>>>> Line:	360
	; >>>>> if(traveser->blocker == semaphore){ 
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_106
	; >>>>> Line:	361
	; >>>>> traveser->state = 1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	362
	; >>>>> traveser->blocker = 0; 
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], 0
	; >>>>> Line:	363
	; >>>>> break; 
	jmp	L_yakc_104
L_yakc_106:
L_yakc_105:
	; >>>>> Line:	366
	; >>>>> traveser = traveser->nextTask; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_103:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_102
L_yakc_104:
	; >>>>> Line:	369
	; >>>>> if (YKISRDepth == 0) { 
	mov	ax, word [YKISRDepth]
	test	ax, ax
	jne	L_yakc_107
	; >>>>> Line:	370
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_107:
	; >>>>> Line:	372
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_100:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_101
	ALIGN	2
YKQCreate:
	; >>>>> Line:	378
	; >>>>> YKQ *YKQCreate(void **start, unsigned size) { 
	jmp	L_yakc_109
L_yakc_110:
	; >>>>> Line:	379
	; >>>>> YKQArray[YKQIdx].length = size; 
	mov	ax, word [YKQIdx]
	mov	cx, 10
	imul	cx
	add	ax, YKQArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	380
	; >>>>> YKQArray[YKQIdx].queueAddress = start; 
	mov	ax, word [YKQIdx]
	mov	cx, 10
	imul	cx
	mov	si, ax
	add	si, YKQArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	381
	; >>>>> YKQArray[YKQIdx].nextEmpty = start; 
	mov	ax, word [YKQIdx]
	mov	cx, 10
	imul	cx
	add	ax, YKQArray
	mov	si, ax
	add	si, 4
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	382
	; >>>>> YKQArray[YKQIdx].nextRemove = start; 
	mov	ax, word [YKQIdx]
	mov	cx, 10
	imul	cx
	add	ax, YKQArray
	mov	si, ax
	add	si, 6
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	383
	; >>>>> YKQArray[YKQIdx].state = 0; 
	mov	ax, word [YKQIdx]
	mov	cx, 10
	imul	cx
	add	ax, YKQArray
	mov	si, ax
	add	si, 8
	mov	word [si], 0
	; >>>>> Line:	385
	; >>>>> YKQIdx++; 
	inc	word [YKQIdx]
	; >>>>> Line:	387
	; >>>>>  
	mov	ax, word [YKQIdx]
	dec	ax
	mov	cx, 10
	imul	cx
	add	ax, YKQArray
L_yakc_111:
	mov	sp, bp
	pop	bp
	ret
L_yakc_109:
	push	bp
	mov	bp, sp
	jmp	L_yakc_110
L_yakc_114:
	DB	", ",0
L_yakc_113:
	DB	"YKQ STRUCT: ",0
	ALIGN	2
debugQueue:
	; >>>>> Line:	391
	; >>>>> void debugQueue(YKQ *queue){ 
	jmp	L_yakc_115
L_yakc_116:
	; >>>>> Line:	392
	; >>>>> printString("YKQ STRUCT: "); 
	mov	ax, L_yakc_113
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	393
	; >>>>> printWord((int) queue->nextEmpty); 
	mov	si, word [bp+4]
	add	si, 4
	push	word [si]
	call	printWord
	add	sp, 2
	; >>>>> Line:	394
	; >>>>> printString(", "); 
	mov	ax, L_yakc_114
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	395
	; >>>>> printWord((int) queue->nextRemove); 
	mov	si, word [bp+4]
	add	si, 6
	push	word [si]
	call	printWord
	add	sp, 2
	; >>>>> Line:	396
	; >>>>> printNewLine(); 
	call	printNewLine
	mov	sp, bp
	pop	bp
	ret
L_yakc_115:
	push	bp
	mov	bp, sp
	jmp	L_yakc_116
	ALIGN	2
YKQPend:
	; >>>>> Line:	399
	; >>>>> void *YKQPend(YKQ *queue) { 
	jmp	L_yakc_118
L_yakc_119:
	; >>>>> Line:	402
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	403
	; >>>>> if(queue->state == 0){ 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_120
	; >>>>> Line:	404
	; >>>>> currentTask->state = 4; 
	mov	si, word [currentTask]
	add	si, 2
	mov	byte [si], 4
	; >>>>> Line:	405
	; >>>>> currentTask->qblocker = queue; 
	mov	si, word [currentTask]
	add	si, 8
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	406
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_120:
	; >>>>> Line:	408
	; >>>>> tempmsg = (void *) *queue->nextRemove; 
	mov	si, word [bp+4]
	add	si, 6
	mov	si, word [si]
	mov	ax, word [si]
	mov	word [bp-2], ax
	; >>>>> Line:	410
	; >>>>> queue->nextRemove++; 
	mov	si, word [bp+4]
	add	si, 6
	add	word [si], 2
	; >>>>> Line:	411
	; >>>>> if(queue->nextRemove == queue->queueAddress + queue->length){ 
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	shl	ax, 1
	mov	si, word [bp+4]
	add	ax, word [si]
	add	si, 6
	mov	dx, word [si]
	cmp	dx, ax
	jne	L_yakc_121
	; >>>>> Line:	412
	; >>>>> ress; 
	mov	si, word [bp+4]
	mov	di, word [bp+4]
	add	di, 6
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_121:
	; >>>>> Line:	416
	; >>>>> if(queue->state == 1){ 
	mov	si, word [bp+4]
	add	si, 8
	cmp	word [si], 1
	jne	L_yakc_122
	; >>>>> Line:	417
	; >>>>> queue->state = 2; 
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], 2
	jmp	L_yakc_123
L_yakc_122:
	; >>>>> Line:	418
	; >>>>> }else if(queue->nextRemove == queue->nextEmpty){ 
	mov	si, word [bp+4]
	add	si, 6
	mov	di, word [bp+4]
	add	di, 4
	mov	ax, word [di]
	cmp	ax, word [si]
	jne	L_yakc_124
	; >>>>> Line:	419
	; >>>>> queue->state = 0; 
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], 0
L_yakc_124:
L_yakc_123:
	; >>>>> Line:	421
	; >>>>> if(0) debugQueue(queue); 
	jmp	L_yakc_125
	; >>>>> Line:	421
	; >>>>> if(0) debugQueue(queue); 
	push	word [bp+4]
	call	debugQueue
	add	sp, 2
L_yakc_125:
	; >>>>> Line:	422
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	423
	; >>>>> return tempmsg; 
	mov	ax, word [bp-2]
L_yakc_126:
	mov	sp, bp
	pop	bp
	ret
L_yakc_118:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_119
	ALIGN	2
YKQPost:
	; >>>>> Line:	426
	; >>>>> int YKQPost(YKQ *queue, void *msg) { 
	jmp	L_yakc_128
L_yakc_129:
	; >>>>> Line:	428
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	430
	; >>>>> if(queue->state == 1){ 
	mov	si, word [bp+4]
	add	si, 8
	cmp	word [si], 1
	jne	L_yakc_130
	; >>>>> Line:	431
	; >>>>> return 0; 
	xor	ax, ax
	jmp	L_yakc_131
L_yakc_130:
	; >>>>> Line:	433
	; >>>>> *queue->nextEmpty = msg; 
	mov	si, word [bp+4]
	add	si, 4
	mov	si, word [si]
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	434
	; >>>>> queue->nextEmpty++; 
	mov	si, word [bp+4]
	add	si, 4
	add	word [si], 2
	; >>>>> Line:	435
	; >>>>> if(queue->nextEmpty == queue->queueAddress + queue->length){ 
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	shl	ax, 1
	mov	si, word [bp+4]
	add	ax, word [si]
	add	si, 4
	mov	dx, word [si]
	cmp	dx, ax
	jne	L_yakc_132
	; >>>>> Line:	436
	; >>>>> queue->nextEmpty = queue->queueAddress; 
	mov	si, word [bp+4]
	mov	di, word [bp+4]
	add	di, 4
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_132:
	; >>>>> Line:	439
	; >>>>> if(queue->state == 0){ 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_133
	; >>>>> Line:	440
	; >>>>> queue->state = 2; 
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], 2
	jmp	L_yakc_134
L_yakc_133:
	; >>>>> Line:	441
	; >>>>> }else if(queue->nextRemove == queue->nextEmpty){ 
	mov	si, word [bp+4]
	add	si, 6
	mov	di, word [bp+4]
	add	di, 4
	mov	ax, word [di]
	cmp	ax, word [si]
	jne	L_yakc_135
	; >>>>> Line:	442
	; >>>>> queue->state = 1; 
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], 1
L_yakc_135:
L_yakc_134:
	; >>>>> Line:	444
	; >>>>> if(0) debugQueue(queue); 
	jmp	L_yakc_136
	; >>>>> Line:	444
	; >>>>> if(0) debugQueue(queue); 
	push	word [bp+4]
	call	debugQueue
	add	sp, 2
L_yakc_136:
	; >>>>> Line:	446
	; >>>>> traveser = taskhead; 
	mov	ax, word [taskhead]
	mov	word [bp-2], ax
	; >>>>> Line:	448
	; >>>>> while(traveser){ 
	jmp	L_yakc_138
L_yakc_137:
	; >>>>> Line:	449
	; >>>>> if(traveser->state == 4){ 
	mov	si, word [bp-2]
	add	si, 2
	cmp	byte [si], 4
	jne	L_yakc_140
	; >>>>> Line:	452
	; >>>>> if(traveser->qblocker == queue){ 
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_141
	; >>>>> Line:	453
	; >>>>> traveser->state = 1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	454
	; >>>>> traveser->qblocker = 0; 
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], 0
	; >>>>> Line:	455
	; >>>>> break; 
	jmp	L_yakc_139
L_yakc_141:
L_yakc_140:
	; >>>>> Line:	458
	; >>>>> traveser = traveser->nextTask; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_138:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_137
L_yakc_139:
	; >>>>> Line:	461
	; >>>>> if (YKISRDepth == 0) { 
	mov	ax, word [YKISRDepth]
	test	ax, ax
	jne	L_yakc_142
	; >>>>> Line:	462
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_142:
	; >>>>> Line:	465
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	467
	; >>>>> return 1; 
	mov	ax, 1
L_yakc_131:
	mov	sp, bp
	pop	bp
	ret
L_yakc_128:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_129
	ALIGN	2
YKEventCreate:
	; >>>>> Line:	472
	; >>>>> YKEVENT *YKEventCreate(unsigned initialValue) { 
	jmp	L_yakc_144
L_yakc_145:
	; >>>>> Line:	473
	; >>>>> YKEArray[ 
	mov	ax, word [YKEIdx]
	shl	ax, 1
	mov	si, ax
	add	si, YKEArray
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	475
	; >>>>> YKEIdx++; 
	inc	word [YKEIdx]
	; >>>>> Line:	477
	; >>>>> return &YKEArray[YKEIdx-1]; 
	mov	ax, word [YKEIdx]
	dec	ax
	shl	ax, 1
	add	ax, YKEArray
L_yakc_146:
	mov	sp, bp
	pop	bp
	ret
L_yakc_144:
	push	bp
	mov	bp, sp
	jmp	L_yakc_145
	ALIGN	2
YKEventPend:
	; >>>>> Line:	480
	; >>>>> unsigned YKEventPend(YKEVENT *event, unsigned eventMask, int waitMode) { 
	jmp	L_yakc_148
L_yakc_149:
	; >>>>> Line:	482
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	483
	; >>>>> if(waitMode == 1){ 
	cmp	word [bp+8], 1
	jne	L_yakc_150
	; >>>>> Line:	484
	; >>>>> if(eventMask == event->value){ 
	mov	si, word [bp+4]
	mov	ax, word [si]
	cmp	ax, word [bp+6]
	jne	L_yakc_151
	; >>>>> Line:	485
	; >>>>> return event->value; 
	jmp	L_yakc_152
	jmp	L_yakc_153
L_yakc_151:
	; >>>>> Line:	487
	; >>>>> currentTask->state = 5; 
	mov	si, word [currentTask]
	add	si, 2
	mov	byte [si], 5
	; >>>>> Line:	488
	; >>>>> currentTask->eblocker = event; 
	mov	si, word [currentTask]
	add	si, 10
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	489
	; >>>>> currentTask->eventMask = eventMask; 
	mov	si, word [currentTask]
	add	si, 12
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	490
	; >>>>> currentTask->waitMode = waitMode; 
	mov	si, word [currentTask]
	add	si, 14
	mov	ax, word [bp+8]
	mov	word [si], ax
	; >>>>> Line:	491
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_153:
	jmp	L_yakc_154
L_yakc_150:
	; >>>>> Line:	496
	; >>>>> if(eventMask & event->value){ 
	mov	ax, word [bp+6]
	mov	si, word [bp+4]
	and	ax, word [si]
	je	L_yakc_155
	; >>>>> Line:	497
	; >>>>> ocke 
	mov	ax, word [si]
	jmp	L_yakc_152
	jmp	L_yakc_156
L_yakc_155:
	; >>>>> Line:	499
	; >>>>> currentTask->state = 5; 
	mov	si, word [currentTask]
	add	si, 2
	mov	byte [si], 5
	; >>>>> Line:	500
	; >>>>> currentTask->eblocker = event; 
	mov	si, word [currentTask]
	add	si, 10
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	501
	; >>>>> currentTask->eventMask = eventMask; 
	mov	si, word [currentTask]
	add	si, 12
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	502
	; >>>>> currentTask->waitMode = waitMode; 
	mov	si, word [currentTask]
	add	si, 14
	mov	ax, word [bp+8]
	mov	word [si], ax
	; >>>>> Line:	503
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_156:
L_yakc_154:
	; >>>>> Line:	507
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	508
	; >>>>> return event->value; 
	mov	si, word [bp+4]
	mov	ax, word [si]
L_yakc_152:
	mov	sp, bp
	pop	bp
	ret
L_yakc_148:
	push	bp
	mov	bp, sp
	jmp	L_yakc_149
	ALIGN	2
YKEventSet:
	; >>>>> Line:	511
	; >>>>> void YKEventSet(YKEVENT *event, unsigned eventMask) { 
	jmp	L_yakc_158
L_yakc_159:
	; >>>>> Line:	514
	; >>>>> event->value = event->value | eventMask; 
	mov	si, word [bp+4]
	mov	ax, word [si]
	or	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	516
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	518
	; >>>>> traveser = taskhead; 
	mov	ax, word [taskhead]
	mov	word [bp-2], ax
	; >>>>> Line:	520
	; >>>>> while(traveser){ 
	jmp	L_yakc_161
L_yakc_160:
	; >>>>> Line:	521
	; >>>>> if(traveser->state == 5){ 
	mov	si, word [bp-2]
	add	si, 2
	cmp	byte [si], 5
	jne	L_yakc_163
	; >>>>> Line:	524
	; >>>>> if(traveser->eblocke 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_164
	; >>>>> Line:	525
	; >>>>> if(traveser->waitMode == 1){ 
	mov	si, word [bp-2]
	add	si, 14
	cmp	word [si], 1
	jne	L_yakc_165
	; >>>>> Line:	526
	; >>>>> if(traveser->eventMask == event->value){ 
	mov	si, word [bp-2]
	add	si, 12
	mov	di, word [bp+4]
	mov	ax, word [di]
	cmp	ax, word [si]
	jne	L_yakc_166
	; >>>>> Line:	527
	; >>>>> traveser->state = 1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	528
	; >>>>> traveser->eblocker = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	529
	; >>>>> traveser->eventMask = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	530
	; >>>>> traveser->waitMode = 0; 
	mov	si, word [bp-2]
	add	si, 14
	mov	word [si], 0
L_yakc_166:
	jmp	L_yakc_167
L_yakc_165:
	; >>>>> Line:	535
	; >>>>> if(traveser->eventMask & event->value){ 
	mov	si, word [bp-2]
	add	si, 12
	mov	ax, word [si]
	mov	si, word [bp+4]
	and	ax, word [si]
	je	L_yakc_168
	; >>>>> Line:	536
	; >>>>> traveser->state = 1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	537
	; >>>>> traveser->eblocker = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	538
	; >>>>> traveser->eventMask = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	539
	; >>>>> traveser->waitMode = 0; 
	mov	si, word [bp-2]
	add	si, 14
	mov	word [si], 0
L_yakc_168:
L_yakc_167:
L_yakc_164:
L_yakc_163:
	; >>>>> Line:	544
	; >>>>> traveser = traveser->nextTask; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_161:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_160
L_yakc_162:
	; >>>>> Line:	547
	; >>>>> if (YKISRDepth == 0) { 
	mov	ax, word [YKISRDepth]
	test	ax, ax
	jne	L_yakc_169
	; >>>>> Line:	548
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_169:
	; >>>>> Line:	550
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_158:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_159
	ALIGN	2
YKEventReset:
	; >>>>> Line:	553
	; >>>>> void YKEventReset(YKEVENT *event, unsigned eventMask) { 
	jmp	L_yakc_171
L_yakc_172:
	; >>>>> Line:	554
	; >>>>> event->value = event->value & (~eventMask); 
	mov	ax, word [bp+6]
	not	ax
	mov	si, word [bp+4]
	and	ax, word [si]
	mov	word [si], ax
	mov	sp, bp
	pop	bp
	ret
L_yakc_171:
	push	bp
	mov	bp, sp
	jmp	L_yakc_172
	ALIGN	2
taskhead:
	TIMES	2 db 0
nextTask:
	TIMES	2 db 0
TCBArray:
	TIMES	180 db 0
SEMArray:
	TIMES	128 db 0
YKQArray:
	TIMES	80 db 0
YKEArray:
	TIMES	16 db 0
YKIdleStk:
	TIMES	512 db 0
YKEnterMutex:
	cli				; disable interrupts
	ret

YKExitMutex:
	sti				; enable interrupts
	ret

YKsavecontext:
	pushf	    	; push the flags
	push	cs		; code segment (segment to which IP refers)
	; PUSH THE INSTRUCTION POINTER
	push word [bp+2]
	labelSaveCtx:
	push	ax
	push	bx
	push	cx
	push	dx
	push	si		; source index
	push	di		; destination index
	push	bp		; base
	push	es		; extra segment
	push	ds		; data segment

	; currentTask is first parameter passed, nextTask is 2nd passed
	; each TCB has 3 ints, 2 chars, and 1 struct pointer (6 things)

	mov bx, [taskSaveCTX]		; save currentTask
	mov	[bx], sp		; set sp and TCB of currentTask
	jmp YKrestorecontext

YKDispatcher:
	labelDispatcher:
	push 	bp					
	mov 	bp, sp
	push 	ax
	mov 	ax, word [bp+4]
	cmp		al, 1 ;Not sure why it cannot move the whole register over... simple fix for now
	pop 	ax
	je 		YKsavecontext

YKrestorecontext:
	mov bx, [nextTask]		; save nextTask
	mov sp, [bx]		; restore context of nextTask by getting sp from TB of nextTask

	pop		ds		; pop everything but ip, cs, and flags (reverse order of course)
	pop		es
	pop		bp
	pop		di
	pop		si
	pop		dx
	pop		cx
	pop		bx
	pop		ax

	iret			; start next task. iret takes care of ip, cs, and flags
